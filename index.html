<!DOCTYPE html>
<html lang="en" dir="rtl">
    <head>
        <meta charset="UTF-8">
        <title>מסלוליק</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
        <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
        <style>
        #map { height: 80vh; width: 100%; border-radius: 0.6rem; box-shadow: 0 2px 12px rgba(0,0,0,0.12); z-index: 10;}
        .leaflet-control { font-size: 1rem; }
        .animated-fade {
            animation: fadeInOut 5s alternate; /* Applies the animation */
        }

        @keyframes fadeInOut {
            0% { opacity: 0; } /* Starts hidden */
            20% { opacity: 1; } /* Fully visible at 50% of animation */
            80% { opacity: 1; } /* Fully visible at 50% of animation */
            100% { opacity: 0; } /* Fades back out */
        }
        </style>
    </head>
    <body>
        <div class="min-h-screen bg-gray-900 text-gray-300 p-6">
            <!-- Header with tabs -->
            <header class="w-full bg-gray-800 shadow p-4 flex flex-col md:flex-row items-center justify-between fixed top-0 left-0 z-10">
                <div class="flex items-center gap-2">
                    <h1 class="text-3xl font-bold drop-shadow-lg flex items-center gap-3">
                        <i class="fa-solid fa-map-location-dot text-blue-400"></i>
                        <span>מסלוליק</span>
                    </h1>
                </div>
                <div class="flex items-center gap-2 mt-2 md:mt-0">
                    <button id="savedTripsBtn" class="px-3 py-1 bg-orange-700 text-white rounded hover:bg-orange-600">
                    <i class="fa-solid fa-list ml-2"></i>המסלולים שלי
                    </button>
                    <button id="tabMap" class="px-3 py-1 bg-blue-700 text-white rounded hover:bg-blue-600">
                        <i class="fa-solid fa-globe ml-2"></i>מפה
                    </button>
                    <button id="tabEditor" class="px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700">
                        <i class="fa-solid fa-pencil ml-2"></i>עורך
                    </button>
                    <a href="user_guide.html" target="_blank"><button id="userGuide" class="px-3 py-1 text-white rounded">
                        <i class="fa-solid fa-circle-info"></i>
                    </button></a>
                </div>
            </header>
            <!-- Main content: Map tab and Editor tab (hidden/shown by tabs) -->
            <main class="">
                <!-- Toast Notification -->
                <div id="toast" class="fixed top-4 mr-50 z-100 hidden animated-fade">
                    <!-- RTL: put toast left -->
                    <div id="toastMsg" class="px-4 py-2 rounded shadow-lg font-bold flex items-center gap-2"></div>
                </div>
                <!-- Saved Trips Modal -->
                <div id="savedTripsModal" class="fixed inset-0 z-20 flex items-center justify-center bg-black/50 hidden">
                    <div class="bg-gray-800 rounded-lg shadow-lg p-6 w-full max-w-xl text-right">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-bold"><i class="fa-solid fa-map-location-dot ml-2"></i>המסלולים שלי</h3>
                            <div class="flex items-center gap-2">
                                <button id="fileLoaderBtn" class="px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700 flex items-center">
                                    <i class="fa-solid fa-folder-open ml-2"></i>יבוא
                                </button>
                                <button id="saveToLibraryBtn" class="px-3 py-1 bg-green-600 text-white rounded"><i class="fa-solid fa-save ml-2"></i>שמור</button>
                                <button id="closeSavedTripsBtn" class="px-3 py-1 bg-gray-600 text-white rounded">סגור</button>
                            </div>
                        </div>
                        <div id="savedTripsList" class="flex flex-col gap-2 max-h-80 overflow-auto">
                            <!-- populated dynamically -->
                        </div>
                    </div>
                </div>
                <!-- Confirmation Modal -->
                <div id="confirmModal" class="fixed inset-0 z-30 flex items-center justify-center bg-black/50 hidden">
                    <div class="bg-gray-800 rounded-lg shadow-lg p-6 w-full max-w-sm text-center">
                        <div id="confirmModalMsg" class="text-lg text-gray-100 mb-6"></div>
                        <div class="flex justify-center gap-4">
                            <button id="confirmYes" class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700">אישור</button>
                            <button id="confirmNo" class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700">ביטול</button>
                        </div>
                    </div>
                </div>
                <!-- Map container -->
                <section id="mapContainer">
                    <div id="headerControls" class="flex items-center gap-4 bg-gray-600 text-gray-200 rounded-lg p-2 mb-2 mt-16">
                        <!-- Map toggle (stays in header but only affects map) -->
                        <div class="flex items-center gap-2">
                            <span class="font-medium text-base text-gray-300">מרחקים</span>
                            <button
                                id="toggleDistances"
                                type="button"
                                aria-pressed="true"
                                aria-label="Toggle distances"
                                class="relative w-12 h-6 rounded-full bg-blue-500 transition focus:outline-none"
                            >
                                <span id="toggleKnob" class="absolute left-1 top-1 w-4 h-4 rounded-full bg-white shadow transition-transform translate-x-0"></span>
                            </button>
                        </div>
                        <!-- placeholder for spacing - file loader moved to editor tab -->
                    </div>
                    <div id="map" style="height:82vh; width:100%; border-radius:0.6rem; box-shadow:0 2px 12px rgba(0,0,0,0.12);"></div>
                </section>
                <!-- Editor container (hidden by default) -->
                <section id="editorContainer" class="hidden">
                    <!-- Editor top bar (file loader lives here) -->
                    <div class="flex items-center gap-4 bg-gray-600 text-gray-200 rounded-lg p-2 mt-16 sticky top-17 z-20 w-full">
                        <!-- <button id="fileLoaderBtn" class="px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700 flex items-center">
                            <i class="fa-solid fa-folder-open ml-2"></i>יבוא מסלול
                        </button> -->
                        <!-- Trip metadata (name & description) -->
                        <div class="flex rounded">
                            <div class="flex bg-gray-800 text-gray-300 rounded">
                                <input id="tripNameInput" type="text" placeholder="שם המסלול" class="input w-48 px-2 py-1 rounded border">
                            </div>
                            <div class="flex bg-gray-800 text-gray-300 rounded mr-4">
                                <input id="tripDescInput" type="text" placeholder="תיאור קצר" class="input w-128 px-2 py-1 rounded border">
                            </div>
                        </div>
                        <input
                            type="file"
                            id="fileLoader"
                            accept="application/json"
                            class="hidden"
                        >
                        <div class="flex-1"></div>
                        <button id="clearAllBtn" class="px-3 py-1 bg-red-600 text-white rounded hover:bg-red-700 flex items-center" aria-label="נקה את כל המסלול">
                            <i class="fa-solid fa-trash-can ml-2"></i>נקה הכל
                        </button>
                        <button id="saveBtn" class="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 flex items-center">
                            <i class="fa-solid fa-save ml-2"></i>שמור
                        </button>
                        <button id="exportBtn" class="px-3 py-1 bg-indigo-600 text-white rounded hover:bg-indigo-700 flex items-center" title="ייצא HTML סטטי">
                            <i class="fa-solid fa-file-arrow-down ml-2"></i>ייצא
                        </button>
                    </div>
                    <!-- Editor area -->
                    <main class="max-w-7xl mx-auto w-full pt-2 pb-24 px-2">
                        <!-- extra bottom padding so fixed footer doesn't cover content -->
                        <div id="editor" class="space-y-6"></div>
                    </main>
                    <!-- Editor footer (fixed to viewport bottom) -->
                    <footer id="editorFooter" class="w-full bg-gray-800 shadow p-2 flex items-center justify-center fixed bottom-0 left-0 z-10">
                        <button id="addDayFooterBtn" class="px-2 py-1 bg-green-700 text-white rounded hover:bg-green-800 flex items-center gap-1">
                            <i class="fa-solid fa-plus"></i> הוסף יום
                        </button>
                    </footer>
                </section>
            </main>
        </div>
        <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
        <script>
    // Shared state and config
    // Trip object shape: { name: string, description: string, days: [ { day, dow, color, attractions: [] } ] }
    // Backwards compatible loaders accept an array of days and wrap it into this object.
    let trip = null; // unified shared trip data for both editor and map

    // Helpers to access days array in the trip object
    function ensureTrip() {
        if (!trip || typeof trip !== 'object') trip = { name: '', description: '', days: [], todos: [], todosCollapsed: false };
        if (!Array.isArray(trip.days)) trip.days = [];
        if (!Array.isArray(trip.todos)) trip.todos = [];
        if (typeof trip.todosCollapsed !== 'boolean') trip.todosCollapsed = false;
        return trip;
    }
    function getDays() { ensureTrip(); return trip.days; }
    function setDays(days) { ensureTrip(); trip.days = Array.isArray(days) ? days : []; }
    let dev_mode = false; // set true to auto-load places.json on startup
        const LS_TRIP_KEY = 'msl_last_trip';
        const LS_ROUTE_CACHE_KEY = 'msl_route_cache';
    // Map lifecycle
    let map = null;
    let baseLayer = null;
    let legendControl = null;
    // Track which days are selected for display on the map
    let selectedDays = [];
    const LS_SELECTED_DAYS_KEY = 'msl_selected_days';
    // Load selectedDays from localStorage if available
    function loadSelectedDays(len) {
        try {
            const raw = localStorage.getItem(LS_SELECTED_DAYS_KEY);
            if (!raw) return Array(len).fill(true);
            const arr = JSON.parse(raw);
            if (Array.isArray(arr) && arr.length === len) return arr;
            return Array(len).fill(true);
        } catch (e) { return Array(len).fill(true); }
    }
    function saveSelectedDays() {
        try { localStorage.setItem(LS_SELECTED_DAYS_KEY, JSON.stringify(selectedDays)); } catch (e) {}
    }
    let refreshTimer = null;
    let routingEnabled = true; // when false, don't call ORS; useful while editing
    function refreshMapDebounced(delay = 600) {
        if (refreshTimer) clearTimeout(refreshTimer);
        refreshTimer = setTimeout(() => {
            const days = getDays();
            if (days && days.length >= 0) {
                // remove overlays (keep base layer) then reload
                if (map && baseLayer) {
                    map.eachLayer(function(layer) { if (layer !== baseLayer) map.removeLayer(layer); });
                }
                loadPlaces(days);
            }
        }, delay);
    }

    // Persist trip to localStorage (debounced)
    let saveTripTimer = null;
    function saveTripToStorageDebounced(delay = 400) {
        if (saveTripTimer) clearTimeout(saveTripTimer);
        saveTripTimer = setTimeout(() => {
            try {
                localStorage.setItem(LS_TRIP_KEY, JSON.stringify(trip));
                // Also persist into saved-trips library automatically when trip has a name
                try {
                    persistTripToSavedLibrary(trip);
                } catch (e) {}
            } catch (e) {
                // ignore storage errors
            }
        }, delay);
    }

    // Persist given trip into the saved trips localStorage key (msl_saved_trips).
    // This helper is safe to call repeatedly; it will only write when trip has a non-empty name.
    function persistTripToSavedLibrary(t) {
        try {
            if (!t || typeof t !== 'object') return;
            const name = (typeof t.name === 'string') ? t.name.trim() : '';
            if (!name) return; // require a name to save into the library
            const key = 'msl_saved_trips';
            const raw = localStorage.getItem(key);
            const store = raw ? JSON.parse(raw) : {};
            // clone to avoid retaining references
            store[name] = JSON.parse(JSON.stringify(t));
            localStorage.setItem(key, JSON.stringify(store));
        } catch (e) {
            // ignore localStorage errors
        }
    }

    // Clipboard helpers for attractions
    const ATTR_CLIPBOARD_KEY = 'msl_clipboard_attraction';

    function copyAttractionToClipboard(dayIdx, attrIdx) {
        try {
            const days = getDays();
            if (!days || !days[dayIdx] || !days[dayIdx].attractions || !days[dayIdx].attractions[attrIdx]) return;
            const a = days[dayIdx].attractions[attrIdx];
            const copyObj = JSON.parse(JSON.stringify(a));
            // store in localStorage for persistence and for cross-tab use
            try { localStorage.setItem(ATTR_CLIPBOARD_KEY, JSON.stringify(copyObj)); } catch (e) {}
            // also try system clipboard
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(JSON.stringify(copyObj)).catch(()=>{});
            }
            showToast('הפעילות הועתקה');
        } catch (e) { showToast('שגיאה בהעתקה', true); }
    }

    function pasteAttractionToDay(dayIdx) {
        try {
            // read from localStorage clipboard first
            const raw = localStorage.getItem(ATTR_CLIPBOARD_KEY);
            if (!raw) { showToast('אין פעילות מועתקת', true); return; }
            const copied = JSON.parse(raw);
            if (!copied || typeof copied !== 'object') { showToast('תוכן לא תקין', true); return; }
            const days = getDays();
            if (!Array.isArray(days)) return;
            if (!days[dayIdx]) {
                // create empty days up to this index
                for (let i = days.length; i <= dayIdx; i++) days.push({ day: i+1, dow: '', attractions: [] });
            }
            if (!Array.isArray(days[dayIdx].attractions)) days[dayIdx].attractions = [];
            // append a cloned attraction
            days[dayIdx].attractions.push(JSON.parse(JSON.stringify(copied)));
            setDays(days);
            renderEditor();
            refreshMapDebounced();
            try { updateAllDayDriveLabels(); updateTripEstDriveLabel(); } catch (e) {}
            saveTripToStorageDebounced(0);
            showToast('הפעילות הודבקה');
        } catch (e) { showToast('שגיאה בהדבקה', true); }
    }

    function loadTripFromStorage() {
        // Read and sanitize persisted trip data. If data is malformed, return null.
        try {
            const raw = localStorage.getItem(LS_TRIP_KEY);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            // parsed can be either the old array-of-days or the new {name,description,days} shape
            const daysSource = Array.isArray(parsed) ? parsed : (parsed && Array.isArray(parsed.days) ? parsed.days : null);
            if (!daysSource) return null;
            const sanitized = [];
            for (let i = 0; i < daysSource.length; i++) {
                const d = daysSource[i];
                if (!d || typeof d !== 'object') continue;
                const dayObj = {};
                dayObj.day = Number.isFinite(d.day) ? d.day : (sanitized.length + 1);
                dayObj.dow = typeof d.dow === 'string' ? d.dow : '';
                dayObj.state = d.state === 'complete' ? 'complete' : 'in-progress';
                // restore explicit ISO date string if present in persisted data
                if (typeof d.date === 'string' && d.date.trim()) {
                    dayObj.date = d.date;
                } else if (Number.isFinite(d.date)) {
                    try { dayObj.date = new Date(d.date).toISOString().slice(0,10); } catch (e) { /* ignore */ }
                }
                dayObj.color = typeof d.color === 'string' ? d.color : undefined;
                // extra color pickers (optional)
                dayObj.colorA = typeof d.colorA === 'string' ? d.colorA : undefined;
                dayObj.colorB = typeof d.colorB === 'string' ? d.colorB : undefined;
                dayObj.attractions = [];
                if (Array.isArray(d.attractions)) {
                    for (let j = 0; j < d.attractions.length; j++) {
                        const a = d.attractions[j];
                        if (!a || typeof a !== 'object') continue;
                        const name = typeof a.name === 'string' ? a.name : '';
                        let lat, lng;
                        if (Array.isArray(a.coordinates) && a.coordinates.length === 2 && Number.isFinite(a.coordinates[0]) && Number.isFinite(a.coordinates[1])) {
                            lat = a.coordinates[0];
                            lng = a.coordinates[1];
                        } else {
                            lat = Number.isFinite(a.lat) ? a.lat : (typeof a.lat === 'string' && a.lat.trim() !== '' ? parseFloat(a.lat) : NaN);
                            lng = Number.isFinite(a.lng) ? a.lng : (typeof a.lng === 'string' && a.lng.trim() !== '' ? parseFloat(a.lng) : NaN);
                        }
                        // if lat/lng are not finite, skip this attraction to avoid runtime errors
                        if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;
                        const url = typeof a.url === 'string' ? a.url : '';
                        const time = typeof a.time === 'string' ? a.time : '';
                        const price = (typeof a.price === 'string') ? a.price : (Number.isFinite(a.price) ? String(a.price) : '');
                        const comments = typeof a.comments === 'string' ? a.comments : '';
                        const enabled = (typeof a.enabled === 'boolean') ? a.enabled : true;
                        dayObj.attractions.push({ name: name, coordinates: [lat, lng], url: url, time: time, price: price, comments: comments, enabled: enabled });
                    }
                }
                sanitized.push(dayObj);
            }
            if (!sanitized.length) return null;
            // Build trip object. If parsed was already an object, preserve its name/description/todos if present.
            const tripObj = {
                name: (parsed && typeof parsed === 'object' && typeof parsed.name === 'string') ? parsed.name : '',
                description: (parsed && typeof parsed === 'object' && typeof parsed.description === 'string') ? parsed.description : '',
                days: sanitized,
                todos: (parsed && typeof parsed === 'object' && Array.isArray(parsed.todos)) ? parsed.todos : [],
                todosCollapsed: (parsed && typeof parsed === 'object' && typeof parsed.todosCollapsed === 'boolean') ? parsed.todosCollapsed : false
            };
            return tripObj;
        } catch (e) {
            // Malformed JSON or other error -> ignore persisted data
            return null;
        }
    }

    // Polyline decoder and routing (kept from original index.html)
    //const ORS_API_KEY = '';
    // simple in-memory cache for ORS responses: key -> Promise|routeObject
    const routeCache = new Map();
    function routeKey(lat1, lng1, lat2, lng2) {
        // fixed precision to avoid tiny float differences
        return `${lat1.toFixed(6)},${lng1.toFixed(6)}|${lat2.toFixed(6)},${lng2.toFixed(6)}`;
    }
    function decodePolyline(str, precision) {
        let index = 0, lat = 0, lng = 0, coordinates = [], shift = 0, result = 0, byte = null;
        precision = Math.pow(10, -(precision || 5));
        while (index < str.length) {
            shift = 0; result = 0;
            do {
                byte = str.charCodeAt(index++) - 63;
                result |= (byte & 0x1f) << shift;
                shift += 5;
            } while (byte >= 0x20);
            let deltaLat = ((result & 1) ? ~(result >> 1) : (result >> 1));
            lat += deltaLat;
            shift = 0; result = 0;
            do {
                byte = str.charCodeAt(index++) - 63;
                result |= (byte & 0x1f) << shift;
                shift += 5;
            } while (byte >= 0x20);
            let deltaLng = ((result & 1) ? ~(result >> 1) : (result >> 1));
            lng += deltaLng;
            coordinates.push([lat * precision, lng * precision]);
        }
        return coordinates;
    }
    async function getRoute(lat1, lng1, lat2, lng2) {
        const key = routeKey(lat1, lng1, lat2, lng2);
        if (routeCache.has(key)) {
            // cache may hold a Promise or final object
            return await routeCache.get(key);
        }
        const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImNjMWRjYzY4MTQxMTQ1N2ZhNDVkNWJkZTQwZjZlMGRjIiwiaCI6Im11cm11cjY0In0=`;
        const body = { coordinates: [[lng1, lat1], [lng2, lat2]] };
        // store the fetching promise first to dedupe concurrent requests
        const p = (async () => {
            try {
                const response = await fetch(url, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body) });
                if (!response.ok) throw new Error('ORS error');
                const result = await response.json();
                const route = result.routes[0] || null;
                // replace promise with final value
                routeCache.set(key, Promise.resolve(route));
                // persist this route in localStorage cache (serializable)
                try { persistRouteCacheEntry(key, route); } catch (e) { /* ignore */ }
                return route;
            } catch (e) {
                // cache a null result to avoid retry storms; allow future manual cache clear
                routeCache.set(key, Promise.resolve(null));
                try { persistRouteCacheEntry(key, null); } catch (e) {}
                return null;
            }
        })();
        routeCache.set(key, p);
        return await p;
    }

    // Persist a single route object into localStorage-backed cache
    function persistRouteCacheEntry(key, routeObj) {
        try {
            const raw = localStorage.getItem(LS_ROUTE_CACHE_KEY);
            const store = raw ? JSON.parse(raw) : {};
            store[key] = routeObj; // routeObj may be null
            localStorage.setItem(LS_ROUTE_CACHE_KEY, JSON.stringify(store));
        } catch (e) {
            // ignore localStorage failures
        }
    }

    // Load persisted cache entries into in-memory routeCache
    function loadRouteCacheFromStorage() {
        try {
            const raw = localStorage.getItem(LS_ROUTE_CACHE_KEY);
            if (!raw) return;
            const store = JSON.parse(raw);
            if (!store || typeof store !== 'object') return;
            Object.keys(store).forEach(k => {
                const v = store[k];
                // Accept only null or plain objects as cached route entries
                if (v === null || typeof v === 'object') {
                    routeCache.set(k, Promise.resolve(v));
                }
            });
        } catch (e) {
            // ignore malformed cache
        }
    }

    // Estimate total driving time for the trip using cached ORS durations when available, falling back to haversine heuristic
    function estimateTripDriveTimeMinutes(days) {
        if (!Array.isArray(days) || days.length === 0) return 0;
        const avgKph = 50; // fallback average speed
        
        let minutes = 0;
        for (let i = 0; i < days.length; i++) {
            const at = days[i].attractions || [];
            // within-day segments
            for (let j = 0; j < at.length - 1; j++) {
                const a1 = at[j].coordinates, a2 = at[j+1].coordinates;
                if (!a1 || !a2) continue;
                const lat1 = Number(a1[0]), lng1 = Number(a1[1]);
                const lat2 = Number(a2[0]), lng2 = Number(a2[1]);
                if (!isFinite(lat1) || !isFinite(lng1) || !isFinite(lat2) || !isFinite(lng2)) continue;
                const cached = getCachedRouteDurationMinutesFromStorage(lat1,lng1,lat2,lng2);
                if (cached !== null) {
                    minutes += cached;
                } else {
                    const km = haversineKm(lat1,lng1,lat2,lng2);
                    minutes += Math.round((km / avgKph) * 60);
                }
            }
            // between-days: last attraction of this day to first of next day
            if (i < days.length - 1) {
                const last = (at.length ? at[at.length-1] : null);
                const nextAt = (days[i+1].attractions && days[i+1].attractions.length) ? days[i+1].attractions[0] : null;
                if (last && nextAt && last.coordinates && nextAt.coordinates) {
                    const lat1 = Number(last.coordinates[0]), lng1 = Number(last.coordinates[1]);
                    const lat2 = Number(nextAt.coordinates[0]), lng2 = Number(nextAt.coordinates[1]);
                    if (isFinite(lat1) && isFinite(lng1) && isFinite(lat2) && isFinite(lng2)) {
                        const cached = getCachedRouteDurationMinutesFromStorage(lat1,lng1,lat2,lng2);
                        if (cached !== null) {
                            minutes += cached;
                        } else {
                            const km = haversineKm(lat1,lng1,lat2,lng2);
                            minutes += Math.round((km / avgKph) * 60);
                        }
                    }
                }
            }
        }
        // add 10% buffer for stops/routing inefficiencies
        return Math.round(minutes * 1.1);
    }

    function updateTripEstDriveLabel() {
        try {
            const el = document.getElementById('tripEstDrive');
            if (!el) { el.textContent = `משך נהיגה: 0 שעות`; return; }
            const mins = estimateTripDriveTimeMinutes(getDays());
            if (!mins) { el.textContent = `משך נהיגה: 0 שעות`; return; }
            const h = Math.floor(mins / 60); const m = mins % 60;
            el.textContent = `משך נהיגה: ${h} שעות ו ${m} דקות`;
        } catch (e) {}
    }

    function updateAllDayDriveLabels() {
        try {
            const days = getDays(); if (!Array.isArray(days)) { el.textContent = `משך נהיגה: 0 שעות`; return; };
            days.forEach((d, idx) => {
                const el = document.getElementById('dayDrive-' + idx);
                if (!el) { el.textContent = `משך נהיגה: 0 שעות`; return; }
                const mins = estimateDayDriveMinutes(d);
                if (!mins) { el.textContent = `משך נהיגה: 0 שעות`; return; }
                const h = Math.floor(mins/60), m = mins % 60;
                el.textContent = `משך נהיגה: ${h} שעות ו ${m} דקות`;
            });
        } catch (e) {}
    }

    // Read cached ORS route durations from localStorage-backed route cache if present
    function getCachedRouteDurationMinutesFromStorage(lat1,lng1,lat2,lng2) {
        try {
            const raw = localStorage.getItem(LS_ROUTE_CACHE_KEY);
            if (!raw) return null;
            const store = JSON.parse(raw);
            const key = routeKey(lat1,lng1,lat2,lng2);
            const entry = store[key];
            if (!entry || !entry.summary || typeof entry.summary.duration !== 'number') return null;
            return Math.round(entry.summary.duration / 60);
        } catch (e) { return null; }
    }

    function haversineKm(lat1, lng1, lat2, lng2) {
        const toRad = x => x * Math.PI / 180; const R = 6371;
        const dLat = toRad(lat2 - lat1); const dLng = toRad(lng2 - lng1);
        const a = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLng/2)*Math.sin(dLng/2);
        const c = 2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); return R*c;
    }

    // Estimate driving minutes for a single day using cached ORS durations, fallback to haversine
    function estimateDayDriveMinutes(dayObj) {
        if (!dayObj || !Array.isArray(dayObj.attractions) || dayObj.attractions.length < 2) return 0;
        let mins = 0; const avgKph = 50;
        for (let i = 0; i < dayObj.attractions.length - 1; i++) {
            const a1 = dayObj.attractions[i], a2 = dayObj.attractions[i+1];
            if (!a1 || !a2 || !a1.coordinates || !a2.coordinates) continue;
            const lat1 = Number(a1.coordinates[0]), lng1 = Number(a1.coordinates[1]);
            const lat2 = Number(a2.coordinates[0]), lng2 = Number(a2.coordinates[1]);
            if (!isFinite(lat1) || !isFinite(lng1) || !isFinite(lat2) || !isFinite(lng2)) continue;
            const cached = getCachedRouteDurationMinutesFromStorage(lat1,lng1,lat2,lng2);
            if (cached !== null) {
                mins += cached;
            } else {
                const km = haversineKm(lat1,lng1,lat2,lng2);
                mins += Math.round((km / avgKph) * 60);
            }
        }
        return mins;
    }

    // Map plotting logic (adapted from loadPlaces in original index.html)
    async function loadPlaces(data) {
        if (!data) return;
        if (Array.isArray(data) && data.length === 0) {
            // no days -> remove existing legend and return early
            if (legendControl && map) {
                try { map.removeControl(legendControl); } catch (e) {}
                legendControl = null;
            }
            return;
        }
    // normalize into trip.days for runtime
    const daysArr = Array.isArray(data) ? data : (data && data.days ? data.days : []);
    setDays(daysArr);
    // collect all attraction coordinates to fit map bounds later
    let boundsLatLngs = [];
        // helper: haversine
        function haversine(lat1, lng1, lat2, lng2) {
            const toRad = x => x * Math.PI / 180; const R = 6371;
            const dLat = toRad(lat2 - lat1); const dLng = toRad(lng2 - lng1);
            const a = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLng/2)*Math.sin(dLng/2);
            const c = 2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); return R*c;
        }

        // Clear previous overlays but keep base layer
        if (map) {
            map.eachLayer(function(layer) { if (layer !== baseLayer) map.removeLayer(layer); });
        }

        // Get day colors
        const dayColors = data.map(dayObj => dayObj.color || 'gray');
        // Initialize selectedDays if not set or if data length changed
        if (!Array.isArray(selectedDays) || selectedDays.length !== data.length) {
            selectedDays = loadSelectedDays(data.length);
        }

        // Center map on first attraction if available
        if (data[0] && data[0].attractions && data[0].attractions[0]) {
            map.setView(data[0].attractions[0].coordinates, 9);
        }

        // Remove existing legend
        if (legendControl) { try { map.removeControl(legendControl); } catch (e) {} legendControl = null; }
        legendControl = L.control({position: 'topright'});
        legendControl.onAdd = function(map) {
            const div = document.createElement('div');
            let legendHtml = '<span class="text-lg font-bold mb-2 block">הצג ימים:</span>';
            legendHtml += '<div class="flex flex-col gap-2">';
            data.forEach((dayObj, i) => {
                const color = dayColors[i % dayColors.length];
                legendHtml += `<label class="flex items-center gap-2 cursor-pointer"><input type="checkbox" class="legend-day-checkbox" data-day-idx="${i}" ${selectedDays[i] ? 'checked' : ''}><span class="inline-block w-4 h-4 rounded-full border border-white" style="background:${color};"></span> <span class="text-base">יום ${dayObj.day} (${dayObj.dow})</span></label>`;
            });
            legendHtml += '</div>';
            legendHtml += '<div class="flex gap-2 mt-2"><button type="button" class="legend-select-all px-2 py-1 bg-blue-600 text-white rounded">בחר הכל</button><button type="button" class="legend-unselect-all px-2 py-1 bg-gray-600 text-white rounded">נקה הכל</button></div>';
            div.innerHTML = legendHtml;
            div.className = 'shadow-xl rounded-2xl p-4 bg-gray-800 border border-gray-700 flex flex-col gap-2 text-gray-100';
            // Add event listeners for checkboxes and buttons
            setTimeout(() => {
                const checkboxes = div.querySelectorAll('.legend-day-checkbox');
                checkboxes.forEach(cb => {
                    cb.addEventListener('change', function() {
                        const idx = Number(cb.getAttribute('data-day-idx'));
                        selectedDays[idx] = cb.checked;
                        saveSelectedDays();
                        refreshMapDebounced(0);
                    });
                });
                const selectAllBtn = div.querySelector('.legend-select-all');
                if (selectAllBtn) selectAllBtn.addEventListener('click', function() {
                    selectedDays = Array(data.length).fill(true);
                    saveSelectedDays();
                    refreshMapDebounced(0);
                });
                const unselectAllBtn = div.querySelector('.legend-unselect-all');
                if (unselectAllBtn) unselectAllBtn.addEventListener('click', function() {
                    selectedDays = Array(data.length).fill(false);
                    saveSelectedDays();
                    refreshMapDebounced(0);
                });
            }, 0);
            return div;
        };
        legendControl.addTo(map);

        // Toggle and storage
        let showDistances = true;
        const toggleBtn = document.getElementById('toggleDistances');
        const toggleKnob = document.getElementById('toggleKnob');
        let distanceMarkers = [];
        let routePolylines = [];
        let straightPolylines = [];

        function updateToggleUI() {
            if (showDistances) {
                toggleBtn.classList.remove('bg-gray-300'); toggleBtn.classList.add('bg-blue-500'); toggleBtn.setAttribute('aria-pressed', 'true'); toggleKnob.style.transform = 'translateX(0)';
                routePolylines.forEach(p => map.addLayer(p)); straightPolylines.forEach(p => map.removeLayer(p));
            } else {
                toggleBtn.classList.remove('bg-blue-500'); toggleBtn.classList.add('bg-gray-300'); toggleBtn.setAttribute('aria-pressed', 'false'); toggleKnob.style.transform = 'translateX(24px)';
                routePolylines.forEach(p => map.removeLayer(p)); straightPolylines.forEach(p => map.addLayer(p));
            }
        }
        toggleBtn.onclick = function() { showDistances = !showDistances; distanceMarkers.forEach(m => { if (showDistances) map.addLayer(m); else map.removeLayer(m); }); updateToggleUI(); };
        updateToggleUI();

        async function addRouteAndDistance(lat1, lng1, lat2, lng2, color, weight, dashArray) {
            // Always add straight polyline (serves as fallback/preview while editing)
            const straight = L.polyline([[lat1, lng1], [lat2, lng2]], { color: color, weight: weight, opacity: 0.5, dashArray: dashArray || null });
            straightPolylines.push(straight);
            if (!showDistances) straight.addTo(map);
            // If routing is disabled (editing), skip ORS requests and return
            if (!routingEnabled) return;
            // Otherwise, fetch route from ORS and add route polyline + optional distance marker
            const route = await getRoute(lat1, lng1, lat2, lng2);
            if (route && route.geometry) {
                const coords = decodePolyline(route.geometry, 5);
                const polyline = L.polyline(coords, { color: color, weight: weight, opacity: 0.8, dashArray: dashArray || null });
                routePolylines.push(polyline);
                if (showDistances) polyline.addTo(map);
                const dist = route.summary.distance / 1000; const duration = route.summary.duration / 60;
                if (dist >= 10) {
                    const centerLat = (lat1 + lat2)/2; const centerLng = (lng1 + lng2)/2;
                    const marker = L.marker([centerLat, centerLng], { icon: L.divIcon({ className: 'distance-label', html: `<span class="bg-white p-1 rounded-lg border border-gray-300 text-gray-800 shadow inline-block text-xs">${dist.toFixed(1)}km ${duration.toFixed(0)}min</span>` }), interactive: true });
                    marker.addTo(map); distanceMarkers.push(marker);
                    marker.on('mouseover', function() { if (polyline) { polyline.setStyle({weight: Math.max(weight * 1.8, weight + 2), opacity: 1}); if (polyline.bringToFront) polyline.bringToFront(); } });
                    marker.on('mouseout', function() { if (polyline) { polyline.setStyle({weight: weight, opacity: 0.8}); } });
                }
            }
        }

        // Plot attractions and routes
        data.forEach((dayObj, i) => {
            if (!selectedDays[i]) return;
            const color = dayColors[i % dayColors.length];
            // Only enabled attractions
            const enabledAttractions = dayObj.attractions.filter(attr => attr.enabled !== false);
            enabledAttractions.forEach((attraction, j) => {
                const [lat, lng] = attraction.coordinates;
                const marker = L.circleMarker([lat, lng], { color: (j === 0) ? 'black' : color, fillColor: color, fillOpacity: 0.8, radius: 6, weight: (j === 0) ? 2 : 1 }).addTo(map);
                // save coordinate for fitBounds
                try { boundsLatLngs.push([lat, lng]); } catch (e) {}
                marker.bindTooltip(`${attraction.name} (יום ${dayObj.day}, ${dayObj.dow})`, {permanent:false,direction:'top'});
                const url = `https://www.google.com/maps?q=${lat},${lng}`;
                marker.on('click', function() { window.open(url, '_blank'); });
            });
            if (enabledAttractions.length > 1) {
                let latlngs = enabledAttractions.map(attr => attr.coordinates);
                for (let k = 0; k < latlngs.length - 1; k++) {
                    addRouteAndDistance(latlngs[k][0], latlngs[k][1], latlngs[k+1][0], latlngs[k+1][1], color, 3);
                }
            }
        });
        for (let i = 0; i < data.length - 1; i++) {
            // Only connect between visible days
            if (!selectedDays[i] || !selectedDays[i+1]) continue;
            const lastAttr = data[i].attractions[data[i].attractions.length - 1];
            const nextFirstAttr = data[i+1].attractions[0];
            if (lastAttr && nextFirstAttr) addRouteAndDistance(lastAttr.coordinates[0], lastAttr.coordinates[1], nextFirstAttr.coordinates[0], nextFirstAttr.coordinates[1], 'black', 1, '4 4');
        }
        // Fit map to show all attractions if any coordinates were collected
        if (boundsLatLngs.length > 0) {
            try {
                map.fitBounds(boundsLatLngs, { padding: [40, 40], maxZoom: 15 });
            } catch (e) {
                // ignore fitBounds errors
            }
        }
    }

    // ---------------- Editor code (adapted from editor.html) ----------------
    // Shared data source: trip.days (use getDays()/setDays())
    function renderEditor() {
        const container = document.getElementById('editor');
        container.innerHTML = '';
        // --- Todo List UI ---
        const tripObj = ensureTrip();
        const todos = tripObj.todos;
        const todoDiv = document.createElement('div');
        todoDiv.className = 'bg-gray-900 rounded-lg p-2 shadow w-full border border-gray-600 text-gray-800 text-right';
        todoDiv.innerHTML = `
            <div class="todoListHeader flex items-center justify-between">
                <h2 class="text-lg font-bold text-gray-200 flex items-center gap-2"><i class="fa-solid fa-list-check"></i>משימות <span id="todoOpenCount" class="text-sm text-gray-400">(0)</span></h2>
                <button id="collapseTodosBtn" class="text-gray-300 hover:text-orange-400 text-lg" title="הסתר/הצג"><i class="fa-solid ${tripObj.todosCollapsed ? 'fa-chevron-down' : 'fa-chevron-up'}"></i></button>
            </div>
            <div id="todoList" class="space-y-2 mb-2 mt-2" style="display:${tripObj.todosCollapsed ? 'none' : 'block'}"></div>
            <div id="todoAddRow" class="flex gap-2 mt-2" style="display:${tripObj.todosCollapsed ? 'none' : 'flex'}">
                <input id="newTodoInput" class="input w-full px-2 py-1 rounded border bg-gray-800 text-white" type="text" placeholder="הוסף משימה..." />
                <button id="addTodoBtn" class="px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700"><i class="fa-solid fa-plus"></i></button>
            </div>
        `;
        container.appendChild(todoDiv);
        // Collapse/expand button logic
        todoDiv.querySelector('.todoListHeader').onclick = function() {
            tripObj.todosCollapsed = !tripObj.todosCollapsed;
            saveTripToStorageDebounced();
            // Toggle UI
            const todoList = todoDiv.querySelector('#todoList');
            const addRow = todoDiv.querySelector('#todoAddRow');
            const icon = todoDiv.querySelector('#collapseTodosBtn i');
            if (tripObj.todosCollapsed) {
                todoList.style.display = 'none';
                addRow.style.display = 'none';
                icon.classList.remove('fa-chevron-up');
                icon.classList.add('fa-chevron-down');
            } else {
                todoList.style.display = 'block';
                addRow.style.display = 'flex';
                icon.classList.remove('fa-chevron-down');
                icon.classList.add('fa-chevron-up');
            }
        };
        // Render todo items
        function renderTodos() {
            const list = todoDiv.querySelector('#todoList');
            list.innerHTML = '';
            todos.forEach((todo, idx) => {
                const item = document.createElement('div');
                item.className = 'flex items-center gap-2 bg-gray-800 rounded px-2 py-1';
                item.setAttribute('draggable', 'false');
                item.setAttribute('data-todo-idx', idx);
                item.innerHTML = `
                    <span class="cursor-move px-1 text-blue-400 order-btn" title="שנה סדר" draggable="true"><i class="fa-solid fa-bars"></i></span>
                    <button class="toggle-todo-btn ${todo.done ? 'text-green-400' : 'text-gray-400'}" title="סמן כבוצע"><i class="fa-solid fa-check"></i></button>
                    <input class="edit-todo-input w-full px-2 py-1 rounded border bg-gray-800 text-white" type="text" value="${todo.text}" />
                    <button class="delete-todo-btn text-red-400 hover:text-red-600" title="מחק"><i class="fa-solid fa-trash"></i></button>
                `;
                // Drag and drop logic (only from handle)
                const handle = item.querySelector('.order-btn');
                handle.addEventListener('dragstart', function(e) {
                    item.classList.add('opacity-50');
                    e.dataTransfer.setData('todoIdx', idx);
                });
                handle.addEventListener('dragend', function(e) {
                    item.classList.remove('opacity-50');
                });
                item.addEventListener('dragend', function(e) {
                    item.classList.remove('opacity-50');
                });
                item.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    item.classList.add('ring-2','ring-blue-400');
                });
                item.addEventListener('dragleave', function(e) {
                    item.classList.remove('ring-2','ring-blue-400');
                });
                item.addEventListener('drop', function(e) {
                    e.preventDefault();
                    item.classList.remove('ring-2','ring-blue-400');
                    const fromIdx = parseInt(e.dataTransfer.getData('todoIdx'));
                    const toIdx = idx;
                    if (fromIdx !== toIdx) {
                        const moved = todos.splice(fromIdx, 1)[0];
                        todos.splice(toIdx, 0, moved);
                        saveTripToStorageDebounced();
                        renderTodos();
                    }
                });
                // Toggle done
                item.querySelector('.toggle-todo-btn').onclick = function() {
                    todos[idx].done = !todos[idx].done;
                    saveTripToStorageDebounced();
                    renderTodos();
                };
                // Edit text
                item.querySelector('.edit-todo-input').onchange = function(e) {
                    todos[idx].text = e.target.value;
                    saveTripToStorageDebounced();
                };
                // Delete
                item.querySelector('.delete-todo-btn').onclick = function() {
                    todos.splice(idx, 1);
                    saveTripToStorageDebounced();
                    renderTodos();
                };
                // Style if done
                if (todo.done) {
                    item.querySelector('.edit-todo-input').classList.add('line-through','text-gray-400');
                }
                list.appendChild(item);
            });
            // update open tasks counter
            try {
                const cntEl = todoDiv.querySelector('#todoOpenCount');
                if (cntEl) {
                    const open = todos.filter(t => !t.done).length;
                    cntEl.textContent = '(' + open + ')';
                }
            } catch (e) {}
        }
        renderTodos();
        // Add new todo
        todoDiv.querySelector('#addTodoBtn').onclick = function() {
            const inp = todoDiv.querySelector('#newTodoInput');
            const val = inp.value.trim();
            if (val) {
                todos.push({ text: val, done: false });
                inp.value = '';
                saveTripToStorageDebounced();
                renderTodos();
            }
        };
        // Enter key adds todo
        todoDiv.querySelector('#newTodoInput').onkeydown = function(e) {
            if (e.key === 'Enter') todoDiv.querySelector('#addTodoBtn').click();
        };
    const hebrewDays = ['ראשון','שני','שלישי','רביעי','חמישי','שישי','שבת'];
        const dayColors = ['#e53e3e','#3182ce','#f6ad55','#ecc94b','#38b2ac','#d53f8c','#4fd1c5'];
        const days = getDays();
        if (!days) setDays([]);
        const _days = getDays();
    _days.forEach((dayObj, dayIdx) => {
            if (!dayObj.color) dayObj.color = dayColors[dayIdx % dayColors.length];
            const dayDiv = document.createElement('div');
            dayDiv.className = `rounded-lg p-3 shadow w-full border text-white ${dayObj.state === 'complete' ? 'bg-green-900 border-green-300' : 'bg-gray-900 border-gray-600'}`;
            dayDiv.setAttribute('data-day-idx', dayIdx);

            // Add event listener for state toggle after rendering
            setTimeout(() => {
                const toggleBtn = dayDiv.querySelector('.toggle-day-state');
                if (toggleBtn) {
                    toggleBtn.addEventListener('click', function() {
                        const days = getDays();
                        const idx = Number(toggleBtn.getAttribute('data-day-idx'));
                        if (!days[idx]) return;
                        days[idx].state = days[idx].state === 'complete' ? 'in-progress' : 'complete';
                        setDays(days);
                        renderEditor();
                        saveTripToStorageDebounced();
                    });
                }
            }, 0);
            // Only allow drag if started from the header (first child)
            dayDiv.addEventListener('dragstart', function(e) {
                // Only allow drag if started from header (first child)
                if (!e.target.classList.contains('day-header')) {
                    e.preventDefault();
                    return;
                }
                e.dataTransfer.setData('dayIdx', dayIdx);
                e.dataTransfer.setData('type', 0); // 0 for day
                dayDiv.classList.add('opacity-50');
            });
            dayDiv.addEventListener('dragend', function(e) { dayDiv.classList.remove('opacity-50'); });
            dayDiv.addEventListener('dragover', function(e) { e.preventDefault(); dayDiv.classList.add('ring-2','ring-blue-400'); });
            dayDiv.addEventListener('dragleave', function(e) { dayDiv.classList.remove('ring-2','ring-blue-400'); });
            dayDiv.addEventListener('drop', function(e) { 
                e.preventDefault(); 
                e.stopPropagation();
                dayDiv.classList.remove('ring-2','ring-blue-400'); 
                const fromIdx = parseInt(e.dataTransfer.getData('dayIdx'));
                const dataType = parseInt(e.dataTransfer.getData('type'));
                const toIdx = dayIdx;
                if (dataType === 1) {
                    // moving attraction, not day
                    const attrIdx = parseInt(e.dataTransfer.getData('attrIdx'));
                    const moved = _days[fromIdx].attractions.splice(attrIdx,1)[0];
                    if (!_days[dayIdx].attractions) _days[dayIdx].attractions = [];
                    _days[toIdx].attractions.push(moved);
                    setDays(_days);
                    try { updateAllDayDriveLabels(); updateTripEstDriveLabel(); } catch (e) {}
                    renderEditor();
                    refreshMapDebounced();
                    saveTripToStorageDebounced();
                    return;
                }
                if (fromIdx !== toIdx) {
                    let originalFirstDow = _days[0] && _days[0].dow ? _days[0].dow : '';
                    const moved = _days.splice(fromIdx,1)[0];
                    _days.splice(toIdx,0,moved);
                    if (toIdx === 0 && originalFirstDow) _days[0].dow = originalFirstDow;
                    setDays(_days);
                    renderEditor();
                    refreshMapDebounced();
                    saveTripToStorageDebounced();
                }
            });
            dayObj.day = dayIdx + 1;
            if (dayIdx === 0) {
                dayDiv.innerHTML = `
                    <div class="flex items-center gap-2 mb-2 cursor-move bg-gray-700 text-white rounded px-2 py-1 day-header" draggable="true">
                        <span class="text-lg font-bold">יום ${dayObj.day}</span>
                        <input type="color" class="w-8 h-8 rounded" value="${dayObj.color || '#ff0000'}" onchange="editDayField(${dayIdx},'color',this.value)">
                        <input class="input w-40 px-2 py-1 rounded border bg-white text-black date-input" type="text" data-day="${dayIdx}" data-iso="${dayObj.date || ''}" value="${(dayObj.date ? (dayObj.dow ? dayObj.dow + ', ' + dayObj.date : dayObj.date) : (dayObj.dow || ''))}" placeholder="בחר תאריך" />
                        <button class="text-red-400 hover:text-red-600" title="מחק יום" onclick="deleteDay(${dayIdx})"><i class="fa-solid fa-trash"></i></button>
                        <button class="text-orange-300 hover:text-orange-300" title="הדבק פעילות" onclick="pasteAttractionToDay(${dayIdx})"><i class="fa-solid fa-paste"></i></button>
                        <span class="mr-8 text-gray-400">|</span>
                        <input type="color" class="ColorA w-8 h-8 mr-auto rounded" value="${dayObj.colorA || '#999999'}" onchange="editDayField(${dayIdx},'colorA',this.value)">
                        <input type="color" class="ColorB w-8 h-8 rounded" value="${dayObj.colorB || '#999999'}" onchange="editDayField(${dayIdx},'colorB',this.value)">
                        <button class="toggle-day-state px-2 py-1 rounded ${dayObj.state === 'complete' ? 'bg-green-500 text-green-900' : 'bg-gray-900 text-white'}" title="סמן יום כ'הושלם'" data-day-idx="${dayIdx}">
                            <i class="fa-solid fa-check"></i>
                        </button>
                        
                    </div>
                    <div class="space-y-2" id="attractions-${dayIdx}"></div>
                    <div class="flex gap-2 mt-2">
                        <button class="px-3 py-1 border border-black bg-green-600 text-white rounded hover:bg-green-700" onclick="addAttraction(${dayIdx})"><i class="fa-solid fa-plus ml-1"></i> הוסף פעילות</button>
                    </div>
                `;
            } else {
                // Prefer deriving from day 0's date if present; otherwise fall back to dow rotation
                if (_days[0] && _days[0].date) {
                    try {
                        const base = new Date(_days[0].date);
                        if (!isNaN(base)) {
                            const d2 = new Date(base);
                            d2.setDate(base.getDate() + dayIdx);
                            dayObj.date = d2.toISOString().slice(0,10);
                            dayObj.dow = hebrewDays[d2.getDay()];
                        } else {
                            // fallback
                            let firstIdx = hebrewDays.indexOf(_days[0].dow);
                            dayObj.dow = hebrewDays[(firstIdx + dayIdx) % hebrewDays.length];
                        }
                    } catch (e) {
                        let firstIdx = hebrewDays.indexOf(_days[0].dow);
                        dayObj.dow = hebrewDays[(firstIdx + dayIdx) % hebrewDays.length];
                    }
                } else if (_days[0] && _days[0].dow) { let firstIdx = hebrewDays.indexOf(_days[0].dow); dayObj.dow = hebrewDays[(firstIdx + dayIdx) % hebrewDays.length]; } else { dayObj.dow = hebrewDays[dayIdx % hebrewDays.length]; }
                dayDiv.innerHTML = `
                    <div class="flex items-center gap-2 mb-2 cursor-move bg-gray-700 text-white rounded px-2 py-1 day-header" draggable="true">
                        <span class="text-lg font-bold">יום ${dayObj.day}</span>
                        <input type="color" class="w-8 h-8 rounded" value="${dayObj.color || '#ff0000'}" onchange="editDayField(${dayIdx},'color',this.value)">
                        <span class="text-lg font-bold">(${dayObj.dow}, ${dayObj.date})</span>
                        <button class="text-red-400 hover:text-red-600" title="מחק יום" onclick="deleteDay(${dayIdx})"><i class="fa-solid fa-trash"></i></button>
                        <button class="text-orange-300 hover:text-orange-300" title="הדבק פעילות" onclick="pasteAttractionToDay(${dayIdx})"><i class="fa-solid fa-paste"></i></button>
                        <span class="mr-8 text-gray-400">|</span>
                        <input type="color" class="ColorA w-8 h-8 mr-auto rounded" value="${dayObj.colorA || '#999999'}" onchange="editDayField(${dayIdx},'colorA',this.value)">
                        <input type="color" class="ColorB w-8 h-8 rounded" value="${dayObj.colorB || '#999999'}" onchange="editDayField(${dayIdx},'colorB',this.value)">
                        <button class="toggle-day-state px-2 py-1 rounded ${dayObj.state === 'complete' ? 'bg-green-500 text-green-900' : 'bg-gray-900 text-white'}" title="סמן יום כ'הושלם'" data-day-idx="${dayIdx}">
                            <i class="fa-solid fa-check"></i>
                        </button>
                    </div>
                    <div class="space-y-2" id="attractions-${dayIdx}"></div>
                    <div class="flex gap-2 mt-2">
                        <button class="px-3 py-1 border border-black bg-green-600 text-white rounded hover:bg-green-700" onclick="addAttraction(${dayIdx})"><i class="fa-solid fa-plus ml-1"></i> הוסף פעילות</button>
                    </div>
                `;
            }
            container.appendChild(dayDiv);
            // Insert per-day total price label next to the colorB input / toggle button.
            try {
                const headerEl = dayDiv.querySelector('.day-header');
                if (headerEl) {
                    // remove previous total if present
                    const prev = headerEl.querySelector('.day-total-price');
                    if (prev) prev.remove();
                    let sum = 0;
                    if (Array.isArray(dayObj.attractions)) {
                        dayObj.attractions.forEach(a => {
                            if (!a) return;
                            // allow values like '12.50' or '$12' or '12'
                            const raw = (a.price === undefined || a.price === null) ? '' : String(a.price);
                            const cleaned = raw.replace(/[^0-9.\-]/g, '');
                            const n = parseFloat(cleaned);
                            if (!isNaN(n)) sum += n;
                        });
                    }
                    const sumDisplay = (sum === 0) ? '' : (sum % 1 === 0 ? String(sum) : sum.toFixed(2));
                    const span = document.createElement('span');
                    span.className = 'text-sm text-gray-300 day-total-price mr-2';
                    // only show when there's a value
                    span.innerHTML = sumDisplay ? `<i class="fa-solid fa-coins"></i> ${sumDisplay}` : '';
                    const toggleBtn = headerEl.querySelector('.ColorA');
                    if (toggleBtn) headerEl.insertBefore(span, toggleBtn);
                    else headerEl.appendChild(span);
                }
            } catch (e) {}

            renderAttractions(dayObj.attractions, dayIdx);
        });
    // previously there was an inline "הוסף יום" button appended here; moved to persistent footer (#addDayFooterBtn)
    // initialize datepickers for any date inputs we added
    try { initDatePickers(); } catch (e) {}
    try { updateTripEstDriveLabel(); } catch (e) {}
    try { updateAllDayDriveLabels(); } catch (e) {}
    }

    function renderAttractions(attractions, dayIdx) {
        const container = document.getElementById(`attractions-${dayIdx}`);
        if (!container) return;
        container.innerHTML = '';
        if (attractions.length > 0) {
            const headerDiv = document.createElement('div'); 
            headerDiv.className = 'flex items-center gap-2 text-sm text-gray-200 text-center w-full'; 
            headerDiv.innerHTML = `
            <span class="w-6 mr-2 rounded bg-gray-900 text-right px-2 py-1"><i class="fa-solid fa-arrows-up-down"></i></span>
            <span class="w-10 rounded bg-gray-900 py-1"><i class="fa-solid fa-comments"></i></span>
            <span class="w-6 rounded bg-gray-900 py-1"><i class="fa-solid fa-route"></i></span>
            <span class="w-16 rounded bg-gray-900 text-right px-2 py-1">שעה</span>
            <span class="w-16 rounded bg-gray-900 py-1"><i class="fa-solid fa-coins"></i></span>
            <span class="w-84 rounded bg-gray-900 text-right px-2 py-1">פעילות</span>
            <span class="w-36 rounded bg-gray-900 text-right px-2 py-1">קואורדינטות</span>
            <span class="w-64 rounded bg-gray-900 text-right px-2 py-1">קישור</span>`; 
            container.appendChild(headerDiv);
        }
        attractions.forEach((attr, attrIdx) => {
            const attrDiv = document.createElement('div');
            attrDiv.className = 'flex items-center gap-2 bg-gray-800 text-gray-300 rounded px-2 py-1 mb-1 w-full';
            attrDiv.setAttribute('data-attr-idx', attrIdx);
            // Only allow drag if started from .order-btn
            attrDiv.addEventListener('dragstart', function(e) {
                if (!e.target.classList.contains('order-btn')) {
                    e.preventDefault();
                    return;
                }
                e.dataTransfer.setData('attrIdx', attrIdx);
                e.dataTransfer.setData('dayIdx', dayIdx);
                e.dataTransfer.setData('type', 1); // 1 for attraction
                attrDiv.classList.add('opacity-50');
                e.stopPropagation();
            });
            attrDiv.addEventListener('dragend', function(e) { attrDiv.classList.remove('opacity-50'); });
            attrDiv.addEventListener('dragover', function(e) { 
                e.preventDefault(); 
                attrDiv.classList.add('ring-2','ring-blue-400'); 
            });
            attrDiv.addEventListener('dragleave', function(e) { attrDiv.classList.remove('ring-2','ring-blue-400'); });
            attrDiv.addEventListener('drop', function(e) { 
                e.preventDefault();
                attrDiv.classList.remove('ring-2','ring-blue-400'); 
                const fromIdx = parseInt(e.dataTransfer.getData('attrIdx')); 
                const fromDayIdx = parseInt(e.dataTransfer.getData('dayIdx')); 
                const dataType = parseInt(e.dataTransfer.getData('type')); 
                const toIdx = attrIdx;
                if (dataType === 0) {
                    // moving day, not attraction
                    console.warn('Invalid drag/drop operation: cannot move attraction as a day'); 
                    return; 
                }
                if (fromDayIdx === dayIdx && fromIdx !== toIdx) { 
                    e.stopPropagation();
                    //same day, just reorder
                        const days = getDays(); const moved = days[dayIdx].attractions.splice(fromIdx,1)[0]; 
                        days[dayIdx].attractions.splice(toIdx,0,moved); setDays(days);
                    try { updateAllDayDriveLabels(); updateTripEstDriveLabel(); } catch (e) {}
                    renderEditor(); 
                    refreshMapDebounced(); 
                    saveTripToStorageDebounced(); 
                }
                else if (fromDayIdx === dayIdx && fromIdx == toIdx) { 
                    e.stopPropagation();
                }
                else if (fromDayIdx !== dayIdx && dataType === 1) { 
                    // moving between days
                    e.stopPropagation();
                        const days = getDays(); const moved = days[fromDayIdx].attractions.splice(fromIdx,1)[0]; 
                        if (!days[dayIdx].attractions) days[dayIdx].attractions = []; 
                        days[dayIdx].attractions.splice(toIdx+1,0,moved); setDays(days);
                    try { updateAllDayDriveLabels(); updateTripEstDriveLabel(); } catch (e) {}
                    renderEditor(); 
                    refreshMapDebounced(); 
                    saveTripToStorageDebounced(); 
                }
            });
            const isExpanded = !!attr._commentsExpanded;
            const commentBtnClass = (attr.comments && attr.comments.trim()) ? 'text-green-300' : 'text-gray-400';
            const enabled = attr.enabled !== false; // default true
                attrDiv.innerHTML = `
                <button class="cursor-move px-1 py-1 text-blue-400 hover:text-blue-600 order-btn" title="שנה סדר" draggable="true"><i class="fa-solid fa-bars"></i></button>
                <button class="px-1 py-1 ml-1 ${commentBtnClass} hover:text-gray-200 comment-toggle-btn" title="הערות" style="font-size:1.2em;">${isExpanded ? '<i class=\"fa-solid fa-chevron-up\"></i>' : '<i class=\"fa-solid fa-comments\"></i>'}</button>
                <button class="ml-1 toggle-attraction-btn ${enabled ? 'text-green-500' : 'text-gray-300'} rounded px-1 py-1" title="${enabled ? 'מוצג במפה' : 'מוסתר מהמפה'}">${enabled ? '<i class=\"fa-solid fa-toggle-on\"></i>' : '<i class=\"fa-solid fa-toggle-off\"></i>'}</button>
                <input class="input w-16 px-2 py-1 rounded border time-input" type="text" data-day="${dayIdx}" data-attr="${attrIdx}" value="${attr.time || ''}" placeholder="hh:mm">
                <input class="input w-16 px-2 py-1 rounded border price-input" type="text" data-day="${dayIdx}" data-attr="${attrIdx}" value="${attr.price || ''}" placeholder="$$$" onchange="editAttraction(${dayIdx},${attrIdx},'price',this.value)">
                <input class="input w-84 px-2 py-1 rounded border" value="${attr.name}" onchange="editAttraction(${dayIdx},${attrIdx},'name',this.value)">
                <input class="input w-36 px-2 py-1 rounded border coordinates" type="text" value="${attr.coordinates ? attr.coordinates.join(',') : ''}" onchange="editAttraction(${dayIdx},${attrIdx},'coordinates',this.value)">
                <input class="input w-64 px-2 py-1 rounded border" type="url" placeholder="https://..." value="${attr.url || ''}" onchange="editAttraction(${dayIdx},${attrIdx},'url',this.value)" dir="ltr">
                <button class="text-red-400 hover:text-red-600 location-btn" title="מפה"><i class="fa-solid fa-location-dot"></i></button>
                <button class="text-sky-300 hover:text-sky-300 waze-btn" title="Waze"><i class="fa-brands fa-waze"></i></button>
                <button class="text-green-400 hover:text-green-600 url-btn" title="קישור"><i class="fa-solid fa-link"></i></button>
                <button class="text-orange-300 hover:text-orange-100 copy-attr-btn" title="העתק פעילות" onclick="copyAttractionToClipboard(${dayIdx},${attrIdx})"><i class="fa-solid fa-copy"></i></button>
                <button class="text-red-400 hover:text-red-600" title="מחק פעילות" onclick="deleteAttraction(${dayIdx},${attrIdx})"><i class="fa-solid fa-trash"></i></button>
            `;
            // Add a separate row for comments (after attrDiv)
            const commentRow = document.createElement('div');
            commentRow.className = 'flex items-center gap-2 bg-gray-800 text-gray-300 rounded px-2 py-1 mb-1 w-full';
            commentRow.style.display = isExpanded ? 'block' : 'none';
            commentRow.innerHTML = `<textarea class="input w-full px-2 py-1 rounded border mt-2" rows="2" placeholder="הערות...">${attr.comments ? attr.comments : ''}</textarea>`;
            // Toggle and save logic
            setTimeout(() => {
                const toggleBtn = attrDiv.querySelector('.comment-toggle-btn');
                if (toggleBtn) {
                    toggleBtn.onclick = function() {
                        attr._commentsExpanded = !attr._commentsExpanded;
                        renderEditor();
                    };
                }
                const textarea = commentRow.querySelector('textarea');
                if (textarea) {
                    // Auto-resize helper: size to content
                    const resizeTextarea = function() {
                        try {
                            textarea.style.height = 'auto';
                            textarea.style.height = (textarea.scrollHeight+10) + 'px';
                        } catch (e) {}
                    };
                    // Initialize size after insertion
                    setTimeout(resizeTextarea, 0);
                    // Resize on input as the user types
                    textarea.addEventListener('input', function() { resizeTextarea(); });
                    // Save on change (existing behavior)
                    textarea.onchange = function() {
                        const days = getDays(); days[dayIdx].attractions[attrIdx].comments = textarea.value; setDays(days);
                        saveTripToStorageDebounced();
                        // Ensure size reflects final content
                        resizeTextarea();
                    };
                }
                // Toggle attraction enabled/disabled
                const enableBtn = attrDiv.querySelector('.toggle-attraction-btn');
                if (enableBtn) {
                    enableBtn.onclick = function() {
                            const days = getDays(); const curr = days[dayIdx].attractions[attrIdx].enabled;
                            days[dayIdx].attractions[attrIdx].enabled = !(curr !== false); // toggle
                        saveTripToStorageDebounced();
                        renderEditor();
                        refreshMapDebounced();
                    };
                }
            }, 0);
            // wire buttons
                setTimeout(() => { // ensure DOM present
                const locationBtn = attrDiv.querySelector('.location-btn'); if (locationBtn) locationBtn.onclick = function() { if(attr.coordinates) onLocationClick(attr.coordinates[0], attr.coordinates[1]); };
                const wazeBtn = attrDiv.querySelector('.waze-btn'); if (wazeBtn) wazeBtn.onclick = function() { if(attr.coordinates) onWazeClick(attr.coordinates[0], attr.coordinates[1]); };
                const urlBtn = attrDiv.querySelector('.url-btn'); if (urlBtn) urlBtn.onclick = function() { onUrlClick(attr.url); };
                // Auto-select coordinates input on focus/click
                const coordInput = attrDiv.querySelector('.coordinates');
                if (coordInput) {
                    coordInput.addEventListener('focus', function(e) { try { e.target.select(); } catch (err) {} });
                    // Prevent mouseup from deselecting the selected text after click
                    coordInput.addEventListener('mouseup', function(e) { try { e.preventDefault(); } catch (err) {} });
                }
            }, 0);
            container.appendChild(attrDiv);
            container.appendChild(commentRow);
        });
    // initialize custom time pickers after DOM insertion
    try { initTimePickers(); } catch (e) {}
    // initialize datepickers (in case any were added inside day header)
    try { initDatePickers(); } catch (e) {}

    // Attach live update handlers for price inputs so the per-day total label updates immediately
    try {
        setTimeout(() => {
            const attractionContainers = document.querySelectorAll('[id^="attractions-"]');
            attractionContainers.forEach(container => {
                const dayId = container.id.split('-')[1];
                const priceInputs = container.querySelectorAll('.price-input');
                priceInputs.forEach(inp => {
                    // avoid double-binding
                    if (inp._priceBound) return; inp._priceBound = true;
                    inp.addEventListener('change', () => {
                        // compute sum for this day
                        let sum = 0;
                        priceInputs.forEach(pi => {
                            const raw = pi.value || '';
                            const cleaned = (""+raw).replace(/[^0-9.\-]/g, '');
                            const n = parseFloat(cleaned);
                            if (!isNaN(n)) sum += n;
                        });
                        // find header in the parent day container
                        const dayContainer = container.parentElement;
                        if (!dayContainer) return;
                        let header = dayContainer.querySelector('.day-header');
                        if (!header) return;
                        let span = header.querySelector('.day-total-price');
                        if (!span) {
                            span = document.createElement('span');                            
                            span.className = 'text-sm text-gray-300 day-total-price mr-2';
                            const toggleBtn = headerEl.querySelector('.ColorA');                            
                            if (toggleBtn) header.insertBefore(span, toggleBtn); else header.appendChild(span);
                        }
                        span.innerHTML = sum ? `<i class="fa-solid fa-coins"></i> ${ (sum % 1 === 0 ? String(sum) : sum.toFixed(2)) }` : '';
                    });
                });
            });
        },0);
    } catch (e) {}
    }

    // Editor utilities and CRUD
    function onLocationClick(lat, lng) { if (Number.isFinite(lat) && Number.isFinite(lng)) window.open(`https://www.google.com/maps?q=${lat},${lng}`, '_blank'); }
    function onWazeClick(lat, lng) { if (Number.isFinite(lat) && Number.isFinite(lng)) {
            // Prefer web Waze link which works on desktop and mobile browsers
            const wazeUrl = `https://waze.com/ul?ll=${lat},${lng}&navigate=yes`;
            window.open(wazeUrl, '_blank');
        } }
    function onUrlClick(url) { if (url && typeof url === 'string' && url.trim()) window.open(url, '_blank'); }
    window.addDay = function() { const days = getDays(); const nextDay = days && days.length ? days[days.length-1].day+1 : 1; days.push({day: nextDay, dow:'', attractions:[], state:'in-progress', color: undefined, colorA: undefined, colorB: undefined}); setDays(days); renderEditor(); refreshMapDebounced(); saveTripToStorageDebounced(); }
    window.deleteDay = function(dayIdx) { showConfirmModal('למחוק את היום הזה?', function(confirmed) { if (confirmed) { const days = getDays(); days.splice(dayIdx,1); setDays(days); renderEditor(); refreshMapDebounced(); saveTripToStorageDebounced(); } }); }
    window.addAttraction = function(dayIdx) { const days = getDays(); if (!days[dayIdx].attractions) days[dayIdx].attractions = []; days[dayIdx].attractions.push({name:'',coordinates:[0,0],time:'',price:'',comments:''}); setDays(days); renderEditor(); refreshMapDebounced(); saveTripToStorageDebounced(); }
    window.deleteAttraction = function(dayIdx, attrIdx) { showConfirmModal('למחוק את הפעילות?', function(confirmed) { if (confirmed) { const days = getDays(); days[dayIdx].attractions.splice(attrIdx,1); setDays(days); renderEditor(); refreshMapDebounced(); saveTripToStorageDebounced(); } }); }
    window.editAttraction = function(dayIdx, attrIdx, field, value) {
        if (field === 'coordinates') {
            // Accept comma or space separated values
            let coords = value.split(/,[ ]?|\s/).map(Number).filter(v => !isNaN(v));
            if (coords.length === 2 && coords.every(Number.isFinite)) {
                // Format to 4 decimal places
                coords = coords.map(n => Number(n.toFixed(4)));
                const days = getDays(); days[dayIdx].attractions[attrIdx].coordinates = coords; setDays(days);
                // Recalculate per-day and trip estimates when coordinates change
                try { updateAllDayDriveLabels(); updateTripEstDriveLabel(); } catch (e) {}
                // Also update the input field to show formatted value
                // Find the input element and update its value
                setTimeout(() => {
                    const container = document.getElementById(`attractions-${dayIdx}`);
                    if (container) {
                        const attrDivs = container.querySelectorAll('[data-attr-idx]');
                        if (attrDivs && attrDivs[attrIdx]) {
                            const coordInput = attrDivs[attrIdx].querySelector('.coordinates');
                            if (coordInput) {
                                coordInput.value = coords.join(',');
                            }
                        }
                    }
                }, 0);
            }
        } else {
            const days = getDays(); days[dayIdx].attractions[attrIdx][field] = value; setDays(days);
        }
        saveTripToStorageDebounced();
        refreshMapDebounced(400);
    }
    
    // Initialize flatpickr time pickers for editor inputs
    function initTimePickers() {
        if (typeof flatpickr !== 'function') return; // not loaded
        const inputs = document.querySelectorAll('.time-input');
        inputs.forEach(inp => {
            // avoid double-init
            if (inp._fp) return;
            const day = parseInt(inp.getAttribute('data-day'));
            const attr = parseInt(inp.getAttribute('data-attr'));
            flatpickr(inp, {
                enableTime: true,
                noCalendar: true,
                dateFormat: 'H:i',
                time_24hr: true,
                defaultDate: inp.value || null,
                onClose: function(selectedDates, dateStr) {
                    // update model
                    if (!Number.isFinite(day) || !Number.isFinite(attr)) return;
                    editAttraction(day, attr, 'time', dateStr || '');
                }
            });
        });
    }
    // Initialize flatpickr date pickers for day header date inputs
    function initDatePickers() {
        if (typeof flatpickr !== 'function') return; // not loaded
        const inputs = document.querySelectorAll('.date-input');
        inputs.forEach(inp => {
            if (inp._fp) return; // already initialized
            // try to read an ISO date stored on the element so we can pass a defaultDate to flatpickr
            const iso = inp.getAttribute('data-iso') || '';
            flatpickr(inp, {
                dateFormat: 'Y-m-d',
                allowInput: true,
                defaultDate: iso || null,
                onChange: function(selectedDates, dateStr) {
                    const dayIdx = Number(inp.getAttribute('data-day'));
                    if (!Number.isFinite(dayIdx)) return;
                    // update model (this will trigger a re-render)
                    editDayField(dayIdx, 'date', dateStr || '');
                    // compute Hebrew weekday for display when possible
                    let display = dateStr || '';
                    if (selectedDates && selectedDates[0]) {
                        const d = selectedDates[0];
                        const hebrewDays = ['ראשון','שני','שלישי','רביעי','חמישי','שישי','שבת'];
                        display = hebrewDays[d.getDay()] + ' ' + dateStr;
                    }
                    // show combined dow + ISO in the visible input
                    try { inp.value = display; } catch (e) {}
                    // keep data-iso attribute in sync
                    try { inp.setAttribute('data-iso', dateStr || ''); } catch (e) {}
                },
                onReady: function(selectedDates, dateStr) {
                    // when flatpickr is ready, if we have an ISO date, ensure the visible value shows dow + date
                    const isoReady = inp.getAttribute('data-iso') || '';
                    if (isoReady) {
                        try {
                            const d = new Date(isoReady);
                            if (!isNaN(d)) {
                                const hebrewDays = ['ראשון','שני','שלישי','רביעי','חמישי','שישי','שבת'];
                                inp.value = hebrewDays[d.getDay()] + ' ' + isoReady;
                            }
                        } catch (e) {}
                    }
                }
            });
        });
    }
    window.editDayField = function(dayIdx, field, value) {
        const days = getDays(); if (!Array.isArray(days)) return;
        const hebrewDays = ['ראשון','שני','שלישי','רביעי','חמישי','שישי','שבת'];
        // ensure target day exists
        if (!days[dayIdx]) return;
        if (field === 'date') {
            // normalize date to ISO YYYY-MM-DD when possible
            let parsed = null;
            if (value && typeof value === 'string' && value.trim()) {
                // let Date parse ISO-like strings
                const d = new Date(value);
                if (!isNaN(d)) parsed = d;
            }
            if (parsed) {
                const iso = parsed.toISOString().slice(0,10);
                days[dayIdx].date = iso;
                // set dow according to JS weekday (0=Sun=>"ראשון")
                days[dayIdx].dow = hebrewDays[parsed.getDay()];
                // if first day changed, propagate sequential dates/dow to following days
                if (dayIdx === 0) {
                    for (let i = 1; i < days.length; i++) {
                        const d2 = new Date(parsed);
                        d2.setDate(parsed.getDate() + i);
                        days[i].date = d2.toISOString().slice(0,10);
                        days[i].dow = hebrewDays[d2.getDay()];
                    }
                }
            } else {
                // fallback: store raw string in dow field and date as raw
                days[dayIdx].date = value;
                days[dayIdx].dow = value;
            }
        } else if (field === 'dow') {
            // if user typed a dow for the first day, propagate weekdays forward
            const idx = hebrewDays.indexOf(value);
            if (idx >= 0 && dayIdx === 0) {
                for (let i = 0; i < days.length; i++) {
                    days[i].dow = hebrewDays[(idx + i) % hebrewDays.length];
                }
            } else {
                days[dayIdx].dow = value;
            }
        } else {
            days[dayIdx][field] = value;
        }
        setDays(days);
        renderEditor();
        refreshMapDebounced();
        saveTripToStorageDebounced();
    }
    
    // Save/download
    document.addEventListener('click', function(e) { if (e.target && e.target.id === 'saveBtn') {
        const b = ensureTrip(); const blob = new Blob([JSON.stringify(b, null, 4)], {type:'application/json'});

        const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url;
        // derive filename from trip name when available
        try {
            const t = ensureTrip(); let fname = (t && t.name) ? String(t.name).trim() : '';
            if (fname) {
                // remove illegal filename chars and collapse whitespace
                fname = fname.replace(/[\\/:*?"<>|]+/g, '').replace(/\s+/g, '_');
                if (!fname.toLowerCase().endsWith('.json')) fname = fname + '.json';
            } else {
                fname = 'places.json';
            }
            a.download = fname;
        } catch (e) { a.download = 'places.json'; }
        a.click(); URL.revokeObjectURL(url); showToast('מסלוליק נשמר בהצלחה!');
    }});

    // Export static HTML (self-contained, no external refs)
    function exportStaticHtml() {
        if (!getDays() || getDays().length === 0) { showToast('אין מה לייצא', true); return; }
        // Minimal inline CSS to keep it readable offline
    const css = `body{font-family:Arial,Helvetica,sans-serif;background:#0b1220;color:#e5e7eb;padding:10px;line-height:1.1;margin:auto;max-width:500px}
                 h1{color:#60a5fa;margin-bottom:2px}h2{color:#bfdbfe;margin:0 0 8px 0; font-size: 18px}
                 a{color:#93c5fd;text-decoration:none} 
                .day{background:#111827;padding:12px;border-radius:8px;margin-bottom:4px;border:1px solid #1f2937; font-size:16px} 
                .title-row{display:flex;align-items:center;gap:10px;margin-bottom:16px} 
                .title-row h2{margin:0} 
                .attr{padding:2px 5px;border-radius:6px;background:#0b1220;border:1px solid #273142;margin:2px 0;display:flex;flex-direction:row;justify-content:space-between; gap:2px} 
                .attr-header{display:flex;align-items:center;gap:10px} 
                .attr-comments{background:#242434;color:#f1f1f1;padding:6px 10px;border-radius:6px;border-width:1px;border-style:solid;border-color:#666677;margin-top:4px;white-space:pre-line;font-size:16px} 
                .dot{width:12px;height:12px;border-radius:50%;display:inline-block;border:1px solid rgba(255,255,255,0.06)} 
                .links{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-top:4px} 
                .icon{width:18px;height:18px;vertical-align:middle;margin-left:6px;fill:currentColor}`;

        // Inline SVG icons
        const svgGm = `<?xml version="1.0" encoding="utf-8"?><svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="20" height="20" viewBox="0 0 92.25 122.88" style="enable-background:new 0 0 92.25 122.88" xml:space="preserve"><style type="text/css"><![CDATA[.st0{fill:#FF6467;}]]></style><g><path class="st0" d="M68.51,106.28c-5.59,6.13-12.1,11.62-19.41,16.06c-0.9,0.66-2.12,0.74-3.12,0.1 c-10.8-6.87-19.87-15.12-27-24.09C9.14,86.01,2.95,72.33,0.83,59.15c-2.16-13.36-0.14-26.22,6.51-36.67 c2.62-4.13,5.97-7.89,10.05-11.14C26.77,3.87,37.48-0.08,48.16,0c10.28,0.08,20.43,3.91,29.2,11.92c3.08,2.8,5.67,6.01,7.79,9.49 c7.15,11.78,8.69,26.8,5.55,42.02c-3.1,15.04-10.8,30.32-22.19,42.82V106.28L68.51,106.28z M46.12,23.76 c12.68,0,22.95,10.28,22.95,22.95c0,12.68-10.28,22.95-22.95,22.95c-12.68,0-22.95-10.27-22.95-22.95 C23.16,34.03,33.44,23.76,46.12,23.76L46.12,23.76z"/></g></svg>`;
        const svgWz = `<?xml version="1.0" encoding="utf-8"?><svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="20" height="20" viewBox="0 0 122.71 122.88" style="enable-background:new 0 0 122.71 122.88" xml:space="preserve"><style type="text/css"><![CDATA[.st1{fill:#71D1E5;}]]></style><g><path class="st1" d="M55.14,104.21c4.22,0,8.44,0.19,12.66-0.09c3.84-0.19,7.88-0.56,11.63-1.5c29.82-7.31,45.76-40.23,32.72-68.07 C104.27,17.76,90.77,8.19,72.3,6.22c-14.16-1.5-26.82,2.72-37.51,12.28c-10.5,9.47-15.94,21.28-16.31,35.44 c-0.09,3.28,0,6.66,0,9.94C18.38,71.02,14.35,76.55,7.5,78.7c-0.09,0-0.28,0.19-0.38,0.19c2.63,6.94,13.31,17.16,19.97,19.69 C35.45,87.14,52.32,91.18,55.14,104.21L55.14,104.21z"/><path d="M54.95,110.49c-1.03,4.69-3.56,8.16-7.69,10.31c-5.25,2.72-10.6,2.63-15.57-0.56c-5.16-3.28-7.41-8.25-7.03-14.35 c0.09-1.03-0.19-1.41-1.03-1.88c-9.1-4.78-16.31-11.44-21.28-20.44c-0.94-1.78-1.69-3.66-2.16-5.63c-0.66-2.72,0.38-4.03,3.19-4.31 c3.38-0.38,6.38-1.69,7.88-4.88c0.66-1.41,1.03-3.09,1.03-4.69c0.19-4.03,0-8.06,0.19-12.1c1.03-15.57,7.5-28.5,19.32-38.63 C42.67,3.97,55.42-0.43,69.76,0.03c25.04,0.94,46.51,18.57,51.57,43.23c4.59,22.32-2.34,40.98-20.07,55.51 c-1.03,0.84-2.16,1.69-3.38,2.44c-0.66,0.47-0.84,0.84-0.56,1.59c2.34,7.13-0.94,15-7.5,18.38c-8.91,4.41-19.22-0.09-21.94-9.66 c-0.09-0.38-0.56-0.84-0.84-0.84C63.11,110.4,59.07,110.49,54.95,110.49L54.95,110.49z M55.14,104.21c4.22,0,8.44,0.19,12.66-0.09 c3.84-0.19,7.88-0.56,11.63-1.5c29.82-7.31,45.76-40.23,32.72-68.07C104.27,17.76,90.77,8.19,72.3,6.22 c-14.16-1.5-26.82,2.72-37.51,12.28c-10.5,9.47-15.94,21.28-16.31,35.44c-0.09,3.28,0,6.66,0,9.94 C18.38,71.02,14.35,76.55,7.5,78.7c-0.09,0-0.28,0.19-0.38,0.19c2.63,6.94,13.31,17.16,19.97,19.69 C35.45,87.14,52.32,91.18,55.14,104.21L55.14,104.21z"/><path d="M74.92,79.74c-11.07-0.56-18.38-4.97-23.07-13.78c-1.13-2.16-0.09-4.31,2.06-4.78c1.31-0.28,2.53,0.66,3.47,2.16 c1.22,1.88,2.44,3.75,4.03,5.25c8.81,8.34,23.25,5.72,28.79-5.06c0.66-1.31,1.5-2.34,3.09-2.34c2.34,0.09,3.66,2.44,2.63,4.59 c-2.91,5.91-7.5,10.22-13.69,12.28C79.51,78.99,76.7,79.36,74.92,79.74L74.92,79.74z"/><path d="M55.32,48.98c-3.38,0-6.09-2.72-6.09-6.09s2.72-6.09,6.09-6.09s6.09,2.72,6.09,6.09C61.42,46.17,58.7,48.98,55.32,48.98 L55.32,48.98z"/><path d="M98.27,42.79c0,3.38-2.72,6.09-6,6.19c-3.38,0-6.09-2.63-6.09-6.09c0-3.38,2.63-6.09,6-6.19 C95.46,36.7,98.17,39.42,98.27,42.79L98.27,42.79z"/></g></svg>`;
        const svgExt = `<?xml version="1.0" encoding="utf-8"?><svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="20" height="20" viewBox="0 0 112.55 122.88" style="enable-background:new 0 0 112.55 122.88" xml:space="preserve"><style type="text/css"><![CDATA[.st2{fill:#11D115;}]]></style><g><path class="st2" d="M104.41,6.1c6.26,5.13,6.93,11.83,7.62,13.46l0.34,2.5c0.9,5.39-1.65,12.75-5.58,17.38L89.2,59.84 c-6.76,7.84-18.04,10.44-27.48,6.37l-0.03,0.04c3.45,5.63,3.15,9.64,3.46,10.57c0.9,5.41-1.65,12.74-5.58,17.38L41.97,114.6 c-8.53,9.89-23.58,11.1-33.53,2.61c-5.04-5.04-7.84-9.31-8.37-16.49c-0.47-6.24,1.53-12.37,5.59-17.18l17.92-20.79 c5.01-5.14,7.5-5.86,13.33-7.47l2.5-0.34l10.66,1.56c0.22,0.08,0.44,0.18,0.65,0.27l0.03-0.04c-5.35-8.71-4.57-20.11,2.14-27.97 L70.48,8.37c4.11-4.77,9.99-7.71,16.15-8.19c5.37-0.89,12.77,1.64,17.38,5.58L104.41,6.1L104.41,6.1z M74.23,51.71l-3.66,4.24 l0.64,0.01l0.02,0l0.6-0.02l0.01,0l0.14-0.01l0.02,0c2.11-0.16,4.19-0.88,5.96-2.14c0.34-0.24,0.68-0.51,1.02-0.82l0,0l0,0 c0.3-0.27,0.62-0.59,0.93-0.95l0,0l0.12-0.13l17.45-20.24c1.47-1.7,2.36-3.75,2.68-5.86c0.07-0.44,0.11-0.87,0.13-1.26 c0.02-0.41,0.01-0.85-0.01-1.28l0-0.05l-0.01-0.11c-0.16-2.11-0.88-4.19-2.14-5.96c-0.24-0.34-0.51-0.67-0.78-0.97l-0.03-0.04 c-0.29-0.32-0.61-0.64-0.94-0.94l0,0l-0.06-0.05l-0.05-0.05L96.16,15c-1.69-1.43-3.7-2.3-5.78-2.61l-0.03,0 c-0.43-0.06-0.85-0.11-1.24-0.12c-0.41-0.02-0.84-0.01-1.27,0.01l-0.07,0l-0.1,0.01c-2.11,0.16-4.19,0.88-5.96,2.14 c-0.34,0.24-0.68,0.51-0.98,0.78l-0.03,0.03c-0.33,0.29-0.64,0.61-0.94,0.95l0,0l-0.12,0.13L62.2,36.55 c-1.47,1.7-2.36,3.75-2.68,5.86h0c-0.06,0.43-0.11,0.86-0.12,1.26c-0.02,0.41-0.01,0.85,0.01,1.28l0.01,0.15l0,0.01v0.02 c0.03,0.46,0.09,0.91,0.18,1.37l3.58-4.15l0.1-0.12l0.13-0.14l0,0l0.02-0.02c1.29-1.39,3.02-2.18,4.79-2.3 c1.78-0.13,3.62,0.39,5.1,1.6l0,0l0.02,0.01l0.09,0.08l0.02,0.02l0.02,0.02l0.01,0.01l0.02,0.01l0.07,0.06l0,0l0,0 c2.06,1.83,2.82,4.6,2.21,7.13c-0.12,0.5-0.3,1-0.54,1.48c-0.22,0.46-0.51,0.9-0.83,1.31l-0.02,0.02l-0.03,0.04l0,0l-0.01,0.02 l-0.1,0.12l0,0L74.23,51.71L74.23,51.71z M40.06,80.23L40.06,80.23c2.33,2.01,5.88,1.75,7.89-0.58l5.58-6.47 c0.65,1.45,1.04,3,1.16,4.57c0.25,3.44-0.79,6.97-3.19,9.75l-17.46,20.24c-2.4,2.79-5.73,4.34-9.16,4.59 c-3.38,0.25-6.84-0.75-9.59-3.05l-0.16-0.14c-2.78-2.4-4.34-5.73-4.59-9.16c-0.25-3.4,0.76-6.89,3.1-9.65l0.09-0.1l17.25-20l0,0 l0,0l0.21-0.24c2.4-2.78,5.73-4.34,9.16-4.59c1.58-0.12,3.18,0.04,4.71,0.47l-5.58,6.47C37.47,74.67,37.73,78.22,40.06,80.23 L40.06,80.23z"/></g></svg>`;
        const svgIcon = `<?xml version="1.0" encoding="utf-8"?><svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="30" height="30" viewBox="0 0 109.69 122.88" style="enable-background:new 0 0 109.69 122.88" xml:space="preserve"><style type="text/css"><![CDATA[.st3{fill:#71D1E5;}]]></style><g><path class="st3" d="M101.41,37.05c-1.95,2.14-4.22,4.05-6.77,5.6c-0.31,0.23-0.74,0.26-1.09,0.03c-3.76-2.39-6.93-5.27-9.41-8.4 c-3.43-4.3-5.59-9.07-6.33-13.66c-0.75-4.66-0.05-9.14,2.27-12.79C81,6.4,82.17,5.08,83.59,3.95c3.27-2.6,7-3.98,10.73-3.95 c3.58,0.03,7.12,1.36,10.18,4.15c1.08,0.98,1.98,2.09,2.72,3.31c2.49,4.11,3.03,9.34,1.93,14.65 C108.07,27.36,105.39,32.69,101.41,37.05L101.41,37.05L101.41,37.05z M23.88,92.06c-1.95,2.14-4.22,4.05-6.77,5.6 c-0.31,0.23-0.74,0.26-1.09,0.03c-3.76-2.4-6.93-5.27-9.41-8.4C3.19,85,1.03,80.23,0.29,75.63c-0.75-4.66-0.05-9.14,2.27-12.78 c0.91-1.44,2.08-2.75,3.51-3.88c3.27-2.6,7-3.98,10.72-3.95c3.58,0.03,7.12,1.36,10.18,4.15c1.08,0.98,1.98,2.09,2.72,3.31 c2.49,4.11,3.03,9.34,1.93,14.65C30.54,82.37,27.86,87.7,23.88,92.06L23.88,92.06L23.88,92.06z M17.07,103.04 c4.51,0,8.32,3.02,9.52,7.14h59.97c2.96,0,5.66-1.21,7.62-3.17c1.96-1.96,3.17-4.65,3.17-7.62l0,0c0-2.96-1.21-5.66-3.17-7.62 c-1.96-1.96-4.65-3.17-7.62-3.17H65.58v0c-4.71,0-8.99-1.92-12.09-5.02c-3.1-3.1-5.02-7.38-5.02-12.09l0,0 c0-4.71,1.92-8.99,5.02-12.09c3.1-3.1,7.38-5.02,12.09-5.02h18.97c1.3-3.96,5.03-6.82,9.42-6.82c5.48,0,9.92,4.44,9.92,9.92 c0,5.48-4.44,9.92-9.92,9.92c-4.35,0-8.04-2.8-9.38-6.69H65.58c-2.96,0-5.66,1.21-7.62,3.17c-1.96,1.96-3.17,4.65-3.17,7.62l0,0 c0,2.96,1.21,5.66,3.17,7.62c1.94,1.94,4.61,3.15,7.55,3.17v0h21.06c4.71,0,8.99,1.92,12.09,5.02c3.1,3.1,5.02,7.38,5.02,12.09l0,0 c0,4.71-1.92,8.99-5.02,12.09c-3.1,3.1-7.38,5.02-12.09,5.02H26.34c-1.43,3.73-5.04,6.37-9.27,6.37c-5.48,0-9.92-4.44-9.92-9.92 C7.15,107.48,11.59,103.04,17.07,103.04L17.07,103.04z M16.08,63.3c4.42,0,8,3.58,8,8c0,4.42-3.58,8-8,8c-4.42,0-8-3.58-8-8 C8.08,66.88,11.66,63.3,16.08,63.3L16.08,63.3z M93.61,8.28c4.42,0,8,3.58,8,8c0,4.42-3.58,8-8,8c-4.42,0-8-3.58-8-8 C85.61,11.86,89.19,8.28,93.61,8.28L93.61,8.28z"/></g></svg>`;
        
    // Build HTML content
    // include trip metadata (name/description) when available
    const _trip = ensureTrip();
    function escHtml(s) { if (!s && s !== 0) return ''; return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }
    let bodyHtml = `<div class="title-row">${svgIcon}<h2>מסלוליק - תוכנית מסלול</h2></div>`;
    if (_trip && _trip.name) bodyHtml += `<div style="margin:10px 0"><h1 style="margin:0;color:#93c5fd;font-size:22px">${escHtml(_trip.name)}</h1></div>`;
    if (_trip && _trip.description) bodyHtml += `<div style="margin-bottom:12px;color:#cbd5e1">${escHtml(_trip.description)}</div>`;
    getDays().forEach(day => {
            const dayColor = day.color || '#38bdf8';
            bodyHtml += `<div class="day" style="border-color:${dayColor}"><h2>יום ${day.day}: ${(day.date ? (day.dow ? day.dow + ', ' + day.date : day.date) : (day.dow || ''))}</h2>`;
            if (Array.isArray(day.attractions) && day.attractions.length) {
                day.attractions.forEach(a => {
                    const [lat, lng] = a.coordinates || [0,0];
                    const gm = `https://www.google.com/maps?q=${lat},${lng}`;
                    const wz = `https://waze.com/ul?ll=${lat},${lng}&navigate=yes`;
                    const urlHtml = a.url ? `<a href="${a.url}" target="_blank" rel="noopener">${svgExt}</a>` : '<span style="width:20px;height:20px;display:inline-block;"></span>';
                    const timeHtml = a.time ? `<span>(${a.time})</span>` : '';
                    const commentsHtml = a.comments ? `<div class="attr-comments">${a.comments.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</div>` : '';
                    bodyHtml += `<div class="attr">
                                    <div class="attr-header">
                                        <strong>${timeHtml}</strong>${a.name || ''}
                                    </div>
                                    <div class="links">
                                        <a href="${gm}" target="_blank" rel="noopener">${svgGm}</a>
                                        <a href="${wz}" target="_blank" rel="noopener">${svgWz}</a>
                                        ${urlHtml}
                                    </div>
                                </div>
                                ${commentsHtml}`;
                });
            } else {
                bodyHtml += `<div class="attr">אין אטרקציות</div>`;
            }
            bodyHtml += `</div>`;
        });

        // Compose full HTML
        const full = `<!doctype html><html lang="he" dir="rtl"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>מסלוליק - תוכנית טיול</title><style>${css}</style></head><body>${bodyHtml}</body></html>`;
        const blob = new Blob([full], {type:'text/html'});
        const url2 = URL.createObjectURL(blob); const a2 = document.createElement('a'); a2.href = url2; a2.download = 'trip_plan.html'; a2.click(); URL.revokeObjectURL(url2); showToast('הייצוא הושלם!');
    }

    // Wire export button
    document.addEventListener('click', function(e) { if (e.target && (e.target.id === 'exportBtn' || e.target.closest && e.target.closest('#exportBtn'))) { exportStaticHtml(); } });

    // Toast and confirm modal (shared)
    function showToast(message, isError) {
        const toast = document.getElementById('toast'); const toastMsg = document.getElementById('toastMsg');
        toastMsg.className = isError ? 'bg-red-600 text-white px-4 py-2 rounded shadow-lg font-bold flex items-center gap-2' : 'bg-green-600 text-white px-4 py-2 rounded shadow-lg font-bold flex items-center gap-2';
        toastMsg.innerHTML = isError ? `<i class='fa-solid fa-xmark text-xl'></i> ${message}` : `<i class='fa-solid fa-check text-xl'></i> ${message}`;
        toast.classList.remove('hidden'); setTimeout(() => { toast.classList.add('hidden'); }, 5000);
    }
    function showConfirmModal(message, callback) {
        const modal = document.getElementById('confirmModal'); const msg = document.getElementById('confirmModalMsg'); const yesBtn = document.getElementById('confirmYes'); const noBtn = document.getElementById('confirmNo'); msg.textContent = message; modal.classList.remove('hidden');
        function cleanup() { modal.classList.add('hidden'); yesBtn.removeEventListener('click', onYes); noBtn.removeEventListener('click', onNo); }
        function onYes() { cleanup(); callback(true); }
        function onNo() { cleanup(); callback(false); }
        yesBtn.addEventListener('click', onYes); noBtn.addEventListener('click', onNo);
    }

    function init_map() {
        if (!map)
        {
            map = L.map('map').setView([20,0],2);
            // Default base layer (OSM)
            window.osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom:18, attribution:'© OpenStreetMap contributors' });
            // Satellite layer (ESRI)
            window.satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                maxZoom: 18,
            });
            // Layer control (built-in Leaflet)
            // Load saved map type preference (defaults to 'standard')
            const LS_MAPTYPE_KEY = 'msl_map_type';
            let saved = null;
            try { saved = localStorage.getItem(LS_MAPTYPE_KEY); } catch (e) { saved = null; }
            // Ensure `baseLayer` references the currently active base so other code preserves it
            if (saved === 'satellite') {
                baseLayer = window.satelliteLayer;
            } else {
                baseLayer = window.osmLayer;
            }
            // Add active base to map
            if (baseLayer && !map.hasLayer(baseLayer)) baseLayer.addTo(map);
            // Build baseMaps after layers are created
            const baseMaps = {
                "מפה": window.osmLayer,
                "לוויין": window.satelliteLayer
            };
            const layersControl = L.control.layers(baseMaps, {}, { position: 'topleft', collapsed: false }).addTo(map);
            // Persist selection when user changes base layer (check layer identity)
            map.on('baselayerchange', function(e) {
                try {
                    if (e && e.layer === window.satelliteLayer) {
                        localStorage.setItem(LS_MAPTYPE_KEY, 'satellite');
                        baseLayer = window.satelliteLayer;
                    } else if (e && e.layer === window.osmLayer) {
                        localStorage.setItem(LS_MAPTYPE_KEY, 'standard');
                        baseLayer = window.osmLayer;
                    } else {
                        // fallback: clear or set to standard
                        localStorage.setItem(LS_MAPTYPE_KEY, 'standard');
                        baseLayer = window.osmLayer;
                    }
                } catch (err) {}
            });
        }
        map.on('contextmenu', function(e) {
            if (e.originalEvent) e.originalEvent.preventDefault();
            const lat = e.latlng.lat.toFixed(4);
            const lng = e.latlng.lng.toFixed(4);
            const text = `${lat},${lng}`;
            // Add a small circle marker for 5 seconds
            const tempMarker = L.circleMarker(e.latlng, {radius: 4, color: '#000000', fillColor: '#666666', fillOpacity: 0.5, weight: 1}).addTo(map);
            setTimeout(() => { map.removeLayer(tempMarker); }, 5000);
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).then(() => {
                    if (typeof showToast === 'function') {showToast('קואורדינטות: ' + text);}
                });
            } else {
                // fallback for older browsers
                const temp = document.createElement('textarea');
                temp.value = text;
                document.body.appendChild(temp);
                temp.select();
                try { document.execCommand('copy'); } catch (err) {}
                document.body.removeChild(temp);
                if (typeof showToast === 'function') {showToast('קואורדינטות: ' + text);}
            }
        });
    }

    // File loader wiring (only in editor tab)
    document.addEventListener('DOMContentLoaded', function() {
        const mapTab = document.getElementById('tabMap'); const editorTab = document.getElementById('tabEditor'); const mapContainer = document.getElementById('mapContainer'); const editorContainer = document.getElementById('editorContainer');
        const headerControlsEl = document.getElementById('headerControls');
        // Store scroll position for tab switching
        let lastEditorScroll = 0;
        let lastMapScroll = 0;
        // Load persisted route cache and last trip from localStorage
        loadRouteCacheFromStorage();
        const storedTrip = loadTripFromStorage();
        if (storedTrip) {
            // loader returns normalized trip object
            trip = storedTrip;
            // ensure UI shows trip metadata (name / description)
            try { populateTripInputs(trip); } catch (e) {}
            renderEditor();
            // do not auto-enable routing here; showMap will enable and refresh
            // but populate map overlays (preview)
            init_map();
            loadPlaces(getDays());
            try { updateAllDayDriveLabels(); updateTripEstDriveLabel(); } catch (e) {}
        }
    function showMap() {
        // Save editor scroll position before hiding
        lastEditorScroll = window.scrollY;
        editorContainer.classList.add('hidden');
        mapContainer.classList.remove('hidden');
        if (headerControlsEl) headerControlsEl.classList.remove('hidden');
        routingEnabled = true;
        refreshMapDebounced(200);
        // Restore map scroll position
        setTimeout(() => { window.scrollTo(0, lastMapScroll || 0); }, 0);
    }
    function showEditor() {
        // Save map scroll position before hiding
        lastMapScroll = window.scrollY;
        mapContainer.classList.add('hidden');
        editorContainer.classList.remove('hidden');
        if (headerControlsEl) headerControlsEl.classList.add('hidden');
        routingEnabled = false;
        refreshMapDebounced(0);
        // Restore editor scroll position
        setTimeout(() => { window.scrollTo(0, lastEditorScroll || 0); }, 0);
    }
    mapTab.onclick = showMap; editorTab.onclick = showEditor; // default: show map
    // Initialize map once (world view)
    init_map();
    showMap();        
    // File loader in editor
    const fileInput = document.getElementById('fileLoader'); const fileBtn = document.getElementById('fileLoaderBtn');
    fileBtn.addEventListener('click', function() { fileInput.click(); });
        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return; const reader = new FileReader();
            reader.onload = function(evt) {
                try {
                    const data = JSON.parse(evt.target.result);
                    // Accept either array (legacy) or new trip object
                    if (Array.isArray(data)) {
                        trip = { name: '', description: '', days: data, todos: [] };
                    } else if (data && typeof data === 'object' && Array.isArray(data.days)) {
                        trip = { name: data.name || '', description: data.description || '', days: data.days, todos: Array.isArray(data.todos) ? data.todos : [] };
                    } else {
                        showToast('קובץ לא תקין', true);
                        return;
                    }
                    // persist trip to storage and render
                    // update visible metadata inputs
                    populateTripInputs(trip);
                    saveTripToStorageDebounced(0);
                    renderEditor();
                    // clear map overlays and load
                    if (map) { map.eachLayer(function(layer) { if (layer !== baseLayer) map.removeLayer(layer); }); map.setView([20,0],2); }
                    loadPlaces(getDays());
                    try { updateAllDayDriveLabels(); updateTripEstDriveLabel(); } catch (e) {}
                    showToast('הקובץ נטען בהצלחה!');
                } catch (err) { showToast('שגיאה בטעינת הקובץ', true); }
            };
            reader.readAsText(file);
        });

        // Saved trips library wiring
        const savedTripsBtn = document.getElementById('savedTripsBtn');
        const savedTripsModal = document.getElementById('savedTripsModal');
        const savedTripsList = document.getElementById('savedTripsList');
        const closeSavedTripsBtn = document.getElementById('closeSavedTripsBtn');
        const saveToLibraryBtn = document.getElementById('saveToLibraryBtn');
        const SAVED_TRIPS_KEY = 'msl_saved_trips';

        function loadSavedTripsFromStorage() {
            try { const raw = localStorage.getItem(SAVED_TRIPS_KEY); return raw ? JSON.parse(raw) : {}; } catch (e) { return {}; }
        }
        function persistSavedTrips(obj) { try { localStorage.setItem(SAVED_TRIPS_KEY, JSON.stringify(obj)); } catch (e) {} }

        function renderSavedTripsList() {
            const store = loadSavedTripsFromStorage();
            savedTripsList.innerHTML = '';
            // Sort by starting date (day 0's date), earliest first; fallback to name
            const keys = Object.keys(store).sort((a, b) => {
                const ta = store[a], tb = store[b];
                const da = ta && ta.days && ta.days[0] && ta.days[0].date ? new Date(ta.days[0].date) : null;
                const db = tb && tb.days && tb.days[0] && tb.days[0].date ? new Date(tb.days[0].date) : null;
                if (da && db && !isNaN(da) && !isNaN(db)) return da - db;
                if (da && !isNaN(da)) return -1;
                if (db && !isNaN(db)) return 1;
                return a.localeCompare(b);
            });
            if (!keys.length) { savedTripsList.innerHTML = '<div class="text-gray-300">אין מסלולים שמורים</div>'; return; }
            keys.forEach(name => {
                const item = document.createElement('div'); 
                item.className = 'flex items-center justify-between p-2 bg-gray-700 rounded';
                item.innerHTML = `
                    <div class="flex flex-col text-right">
                        <strong><i class="fa-solid fa-ellipsis-vertical ml-2"></i>${name} (${(store[name] && store[name].days ? store[name].days[0].date : '')}, ${(store[name] && store[name].days ? store[name].days.length : 0)} ימים)</strong>
                        <small class="text-gray-400">${(store[name] && store[name].description ? store[name].description : "")}</small>
                        
                    </div>
                    <div class="flex gap-2">
                        <button class="load-trip-btn px-2 py-1 bg-blue-600 text-white rounded"><i class="fa-solid fa-upload ml-2"></i>טען</button>
                        <button class="delete-trip-btn px-2 py-1 bg-red-600 hover:bg-red-700 text-white rounded"><i class="fa-solid fa-trash-can"></i></button>
                    </div>`;
                const loadBtn = item.querySelector('.load-trip-btn'); 
                const delBtn = item.querySelector('.delete-trip-btn');
                loadBtn.onclick = function(){ 
                    trip = store[name]; 
                    populateTripInputs(trip);
                    renderEditor(); 
                    loadPlaces(getDays()); 
                    try { updateAllDayDriveLabels(); updateTripEstDriveLabel(); } catch (e) {}
                    saveTripToStorageDebounced(0); 
                    savedTripsModal.classList.add('hidden'); 
                    showToast('המסלול נטען'); };
                delBtn.onclick = function(){
                    showConfirmModal('למחוק את המסלול הזה?', function(confirmed){ if (!confirmed) return; delete store[name]; persistSavedTrips(store); renderSavedTripsList(); showToast('המסלול נמחק'); });
                };
                savedTripsList.appendChild(item);
            });
        }

        function saveTripToList(){
            const t = ensureTrip(); const name = (t.name || '').trim();
            if (!name) { showToast('תן שם למסלול כדי לשמור אותו', true); return; }
            const store = loadSavedTripsFromStorage();
            store[name] = JSON.parse(JSON.stringify(t)); // clone
            persistSavedTrips(store);
            renderSavedTripsList();
            savedTripsModal.classList.add('hidden');
            showToast('המסלול נשמר');
        }

        if (savedTripsBtn) savedTripsBtn.addEventListener('click', function(){ renderSavedTripsList(); savedTripsModal.classList.remove('hidden'); });
        if (closeSavedTripsBtn) closeSavedTripsBtn.addEventListener('click', function(){ savedTripsModal.classList.add('hidden'); });
        // close modal when clicking on the overlay (outside the inner dialog)
        if (savedTripsModal) {
            savedTripsModal.addEventListener('click', function(e) {
                if (e.target === savedTripsModal) savedTripsModal.classList.add('hidden');
            });
        }
        // Confirmation modal overlay close
        const confirmModalEl = document.getElementById('confirmModal');
        if (confirmModalEl) {
            confirmModalEl.addEventListener('click', function(e) {
                if (e.target === confirmModalEl) confirmModalEl.classList.add('hidden');
            });
        }
        if (saveToLibraryBtn) saveToLibraryBtn.addEventListener('click', saveTripToList);

            // Trip metadata inputs wiring (centralized)
            function populateTripInputs(tr) {
                try {
                    const tName = document.getElementById('tripNameInput');
                    const tDesc = document.getElementById('tripDescInput');
                    if (tName) tName.value = (tr && tr.name) ? tr.name : '';
                    if (tDesc) tDesc.value = (tr && tr.description) ? tr.description : '';
                } catch (e) {}
            }
            // simple debounce utility
            function debounce(fn, wait) { let t=null; return function(...args){ if (t) clearTimeout(t); t=setTimeout(()=>{ t=null; fn.apply(this,args); }, wait); }; }
            const saveMetaDebounced = debounce(function(){ saveTripToStorageDebounced(0); refreshMapDebounced(200); }, 300);
            (function attachMetaListeners(){
                try {
                    const tName = document.getElementById('tripNameInput');
                    const tDesc = document.getElementById('tripDescInput');
                    if (tName) tName.addEventListener('input', function(e){ ensureTrip(); trip.name = e.target.value || ''; 
                    //saveMetaDebounced(); 
                });
                    if (tDesc) tDesc.addEventListener('input', function(e){ ensureTrip(); trip.description = e.target.value || ''; saveMetaDebounced(); });
                } catch (e) {}
            })();

        // Clear All button handler
        const clearAllBtn = document.getElementById('clearAllBtn');
        if (clearAllBtn) {
            clearAllBtn.addEventListener('click', function() {
                showConfirmModal('זהו? להתחיל מחדש?', function(confirmed) {
                    if (!confirmed) return;
                    // clear in-memory trip
                    trip = { name: '', description: '', days: [] };
                    // update UI inputs
                    populateTripInputs(trip);
                    // persist cleared trip immediately
                    saveTripToStorageDebounced(0);
                    // update editor
                    renderEditor();
                    // clear map overlays
                    if (map && baseLayer) { map.eachLayer(function(layer) { if (layer !== baseLayer) map.removeLayer(layer); }); }
                    // remove legend if exists
                    if (legendControl && map) { try { map.removeControl(legendControl); } catch (e) {} legendControl = null; }
                    // clear persisted trip and route cache
                    try { localStorage.removeItem(LS_TRIP_KEY); localStorage.removeItem(LS_ROUTE_CACHE_KEY); } catch (e) {}
                    routeCache.clear();
                    showToast('הכל נקי פיקס!');
                });
            });
        }

        // Save button already wired globally via delegated click; ensure saving re-enables routing
        document.addEventListener('click', function(e) { if (e.target && e.target.id === 'saveBtn') {
            routingEnabled = true;
            // persist trip immediately
            saveTripToStorageDebounced(0);
            if (getDays() && getDays().length) { refreshMapDebounced(200); }
        }});

        // Dev mode auto-load
        if (dev_mode) 
        {
            fetch('places.json').then(r => r.json()).then(data => { 
                // accept legacy array or new trip object
                if (Array.isArray(data)) { setDays(data); } else if (data && data.days) { trip = data; } else { setDays([]); }
                renderEditor(); loadPlaces(getDays()); 
            });
        }

    // Footer add-day button wiring (single persistent button)
    const addDayFooterBtn = document.getElementById('addDayFooterBtn');
    if (addDayFooterBtn) addDayFooterBtn.addEventListener('click', function() { addDay(); });
    
    });
        </script>
    </body>
</html>
